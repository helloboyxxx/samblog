<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding SimplePIR & DoublePIR | Yue's Notes</title>
<meta name=keywords content="cryptography"><meta name=description content="Notations


Database size: $N$


Plaintext modulus:$p \in \mathbb{N}$. In SimplePIR, $\log(p) \leq 10$.


Ciphertext modulus: $q \in \mathbb{N}$. In SimplePIR, $\log(q) = 32$.


LWE Dimension: $n = 1024$


LWE secret vector: $\vec{s} \in \mathbb{Z}_q^{n}$.


LWE enc factor: $\Delta = q / p$.


LWE Randomized matrix $A \gets \mathbb{Z}_q^{m \times n}$, where $m$ is the number of samples you want to encrypt.


Plain message vector: $\vec{\mu} \in \mathbb{Z}_p^m$. In simplePIR, we also write $\mu_i$ to denote the vector with all zero entries except a single $1$ at index $i$."><meta name=author content><link rel=canonical href=https://ofuro.me/posts/simple-double/><link crossorigin=anonymous href=/assets/css/stylesheet.3f9c3df41d49c1df83c4f93106bd40eae5ce265f122a1a1a99f034136f7c15f5.css integrity="sha256-P5w99B1Jwd+DxPkxBr1A6uXOJl8SKhoamfA0E298FfU=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/simple-double/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/simple-double/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="Understanding SimplePIR & DoublePIR"><meta property="og:description" content="Notations Database size: $N$
Plaintext modulus:$p \in \mathbb{N}$. In SimplePIR, $\log(p) \leq 10$.
Ciphertext modulus: $q \in \mathbb{N}$. In SimplePIR, $\log(q) = 32$.
LWE Dimension: $n = 1024$
LWE secret vector: $\vec{s} \in \mathbb{Z}_q^{n}$.
LWE enc factor: $\Delta = q / p$.
LWE Randomized matrix $A \gets \mathbb{Z}_q^{m \times n}$, where $m$ is the number of samples you want to encrypt.
Plain message vector: $\vec{\mu} \in \mathbb{Z}_p^m$. In simplePIR, we also write $\mu_i$ to denote the vector with all zero entries except a single $1$ at index $i$."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-11T02:36:16-06:00"><meta property="article:modified_time" content="2025-02-11T02:36:16-06:00"><meta property="article:tag" content="Cryptography"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding SimplePIR & DoublePIR"><meta name=twitter:description content="Notations


Database size: $N$


Plaintext modulus:$p \in \mathbb{N}$. In SimplePIR, $\log(p) \leq 10$.


Ciphertext modulus: $q \in \mathbb{N}$. In SimplePIR, $\log(q) = 32$.


LWE Dimension: $n = 1024$


LWE secret vector: $\vec{s} \in \mathbb{Z}_q^{n}$.


LWE enc factor: $\Delta = q / p$.


LWE Randomized matrix $A \gets \mathbb{Z}_q^{m \times n}$, where $m$ is the number of samples you want to encrypt.


Plain message vector: $\vec{\mu} \in \mathbb{Z}_p^m$. In simplePIR, we also write $\mu_i$ to denote the vector with all zero entries except a single $1$ at index $i$."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"Understanding SimplePIR \u0026 DoublePIR","item":"https://ofuro.me/posts/simple-double/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding SimplePIR \u0026 DoublePIR","name":"Understanding SimplePIR \u0026 DoublePIR","description":"Notations Database size: $N$\nPlaintext modulus:$p \\in \\mathbb{N}$. In SimplePIR, $\\log(p) \\leq 10$.\nCiphertext modulus: $q \\in \\mathbb{N}$. In SimplePIR, $\\log(q) = 32$.\nLWE Dimension: $n = 1024$\nLWE secret vector: $\\vec{s} \\in \\mathbb{Z}_q^{n}$.\nLWE enc factor: $\\Delta = q / p$.\nLWE Randomized matrix $A \\gets \\mathbb{Z}_q^{m \\times n}$, where $m$ is the number of samples you want to encrypt.\nPlain message vector: $\\vec{\\mu} \\in \\mathbb{Z}_p^m$. In simplePIR, we also write $\\mu_i$ to denote the vector with all zero entries except a single $1$ at index $i$.\n","keywords":["cryptography"],"articleBody":"Notations Database size: $N$\nPlaintext modulus:$p \\in \\mathbb{N}$. In SimplePIR, $\\log(p) \\leq 10$.\nCiphertext modulus: $q \\in \\mathbb{N}$. In SimplePIR, $\\log(q) = 32$.\nLWE Dimension: $n = 1024$\nLWE secret vector: $\\vec{s} \\in \\mathbb{Z}_q^{n}$.\nLWE enc factor: $\\Delta = q / p$.\nLWE Randomized matrix $A \\gets \\mathbb{Z}_q^{m \\times n}$, where $m$ is the number of samples you want to encrypt.\nPlain message vector: $\\vec{\\mu} \\in \\mathbb{Z}_p^m$. In simplePIR, we also write $\\mu_i$ to denote the vector with all zero entries except a single $1$ at index $i$.\nLWE Revisit Regev’s LWE-based encryption scheme: $$ \\begin{align*} \\mathsf{Enc}(\\vec{\\mu}) = (c_1, c_2) \u0026= (A, A \\cdot \\vec{s} + \\vec{e} + \\Delta \\vec{\\mu})\\\\ \\mathsf{Dec}(c_1, c_2) \u0026= \\frac{\\mathsf{round}_{\\Delta}(c_2 - c_1 \\cdot \\vec{s})}{\\Delta}\\\\ \\end{align*} $$\nSimplePIR High-level: parse the database into $\\sqrt N \\times \\sqrt N$ square, then use matrix-vector multiplication to retrieve one column. Upload and download size are both $\\sqrt N$ many $\\mathbb{Z}_q$ elements.\n$$ \\begin{align*} \\mathsf{DB}\u0026: \\mathbb{Z}_p^{\\sqrt N \\times \\sqrt N}\\\\ A \u0026: \\mathbb{Z}_q^{\\sqrt N \\times n}\\\\ \\vec{\\mathsf{q_1}} \u0026= A \\cdot \\vec{s} + \\vec{e} + \\Delta \\vec{\\mu_i} = \\mathsf{c_2} \\text{ in }\\mathsf{LWE}(\\mu_i)\\\\ \\mathsf{H}\u0026= \\mathsf{DB} \\times \\mathsf{A} \\in \\mathbb{Z}_q^{\\sqrt N \\times n} \u0026\u0026 \\text{hint matrix}\\\\ \\mathsf{ans} \u0026= \\mathsf{DB} \\cdot \\vec{\\mathsf{q_1}}\u0026\u0026 \\text{one encrypted column} \\end{align*} $$\nWe can recover the whole column:\n$$ \\begin{align*} \\vec{d'} \u0026= \\mathsf{ans} - \\mathsf{H} \\cdot \\vec{s}\\\\ \u0026= \\mathsf{DB} \\cdot \\vec{\\mathsf{q_1}} - (\\mathsf{DB} \\times A) \\cdot \\vec{s}\\\\ \u0026= \\mathsf{DB} \\cdot (A\\cdot \\vec{s} + \\vec{e} + \\Delta \\vec{\\mu_i}) - \\mathsf{DB} \\times A \\cdot \\vec{s}\\\\ \u0026= \\mathsf{DB} \\times A\\cdot \\vec{s} + \\mathsf{DB} \\cdot \\vec{e} + \\Delta \\cdot \\mathsf{DB} \\cdot \\vec{\\mu_i} - \\mathsf{DB} \\times A \\cdot \\vec{s}\\\\ \u0026= \\mathsf{DB} \\cdot \\vec{e} + \\Delta \\cdot \\mathsf{DB} \\cdot \\vec{\\mu_i} \\end{align*} $$\nNow, you can round this result to closest multiple of $\\Delta$, then divide the resulting vector by $\\Delta$ to get the retrieved data.\nObservation The time consuming part is $\\mathsf{DB} \\times A$. However, this is independent to the query and the secrete key. Hence it is used as hint. Since we only need one final entry, instead of decrypting the whole answer vector, we can instead use a single row of $H$ and a single $\\mathbb{Z}_q$ in $\\mathsf{ans}$ for the decryption. DoublePIR Upon decrypting the desired value, the client needs the $j$ th element from $\\mathsf{ans} \\in \\mathbb{Z}_q^{\\sqrt N}$, and the $j$ th row of $\\mathsf{H} \\in \\mathbb{Z}_q^{\\sqrt N \\times n}$. DoublePIR, as suggested in its name, uses another SimplePIR to retrieve these $n + 1$ values. However, with some changes.\nObserve that after running SimplePIR once, $\\mathsf{ans}$ and $\\mathsf{H_1} := \\mathsf{H}$ are all in $\\mathbb{Z}_q$. However, the initial input DB for SimplePIR should be in $\\mathbb{Z}_p$. Hence, a decomposition function $\\mathsf{Decomp}: \\mathbb{Z}_q \\mapsto \\mathbb{Z}_p^{\\kappa}$ is used prior to the second SimplePIR, where $\\kappa = \\lceil \\log q/ \\log p\\rceil$. Now, we treat the decomposed hint $\\mathsf{Decomp}(\\mathsf{H_1}^T)$ as the new database, we can compute the new hint $\\mathsf{H_2} = \\mathsf{Decomp}(\\mathsf{H_1}^T) \\times A_2$, which will be downloaded by the client.\nHowever, we cannot pre-compute the hint for the $\\mathsf{ans}$ vector. Hence, the solution is to create the hint ($\\mathsf{H_3} = \\mathsf{Decomp}(\\mathsf{ans}^T) \\times A_2$) and ask the client to download it together with the other $n+1$ values.\nObservation The new hint $\\mathsf{H_2}$ is only affected by $\\kappa$ and $n$. So the hint size won’t change when $N$ changes. Limitations Extension to large entries In SimplePIR, hint size is $n \\cdot \\sqrt{dN}$ many $\\mathbb{Z}_q$. For a $1\\mathsf{GB}$ database with $4 \\mathsf{KB}$ entires, this means $N = 2^{18}, d = 4096 \\cdot 8 / 9 \\approx 3641, n = 1024$, hint size is roughly $121\\mathsf{MB}$ In DoublePIR, hint size is $d \\kappa n^2$ many $\\mathbb{Z}_q$. Concretely, this means $16 \\mathsf{MB}$ of hint for retreving a $9$-bit entry. If we want to support $4 \\mathsf{KB}$ (same as small OnionPIR), hint size will be $16 \\cdot d \\mathsf{MB} = 58256 \\mathsf{MB} \\approx 56\\mathsf{GB}$. Also in DoublePIR, the response size is proportional to $d$. Download $d \\cdot \\kappa (2n+1)$. In the same $4\\mathsf{KB}$ setting, this means $114$ MB for download. So the expansion faction is still an important metric. Client side computation In the current SimplePIR code base, $A$ is stored and used for creating query. Size of $A$ is same as size of the hint, so in normal setting, 120MB. If we don’t store it, then pseudorandomly generating the matrix $A$ takes about $4.5 \\mathsf{s}$, while the server computation is in $110\\mathsf{ms}$. If we consider this client work for each retrieval, PRG computation will be the dominant factor. This limintation seems to apears in YPIR as well, whose construction was inspired by SimplePIR and DoublePIR.\n","wordCount":"755","inLanguage":"en","datePublished":"2025-02-11T02:36:16-06:00","dateModified":"2025-02-11T02:36:16-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/simple-double/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/ title=Notes><span>Notes</span></a></li><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Understanding SimplePIR & DoublePIR</h1><div class=post-meta><span title='2025-02-11 02:36:16 -0600 -0600'>February 11, 2025</span></div></header><div class=post-content><h3 id=notations>Notations<a hidden class=anchor aria-hidden=true href=#notations>#</a></h3><ul><li><p>Database size: $N$</p></li><li><p>Plaintext modulus:$p \in \mathbb{N}$. In SimplePIR, $\log(p) \leq 10$.</p></li><li><p>Ciphertext modulus: $q \in \mathbb{N}$. In SimplePIR, $\log(q) = 32$.</p></li><li><p>LWE Dimension: $n = 1024$</p></li><li><p>LWE secret vector: $\vec{s} \in \mathbb{Z}_q^{n}$.</p></li><li><p>LWE enc factor: $\Delta = q / p$.</p></li><li><p>LWE Randomized matrix $A \gets \mathbb{Z}_q^{m \times n}$, where $m$ is the number of samples you want to encrypt.</p></li><li><p>Plain message vector: $\vec{\mu} \in \mathbb{Z}_p^m$. In simplePIR, we also write $\mu_i$ to denote the vector with all zero entries except a single $1$ at index $i$.</p></li></ul><h3 id=lwe-revisit>LWE Revisit<a hidden class=anchor aria-hidden=true href=#lwe-revisit>#</a></h3><p>Regev&rsquo;s LWE-based encryption scheme:
<code>$$ \begin{align*} \mathsf{Enc}(\vec{\mu}) = (c_1, c_2) &= (A, A \cdot \vec{s} + \vec{e} + \Delta \vec{\mu})\\ \mathsf{Dec}(c_1, c_2) &= \frac{\mathsf{round}_{\Delta}(c_2 - c_1 \cdot \vec{s})}{\Delta}\\ \end{align*} $$</code></p><h3 id=simplepir>SimplePIR<a hidden class=anchor aria-hidden=true href=#simplepir>#</a></h3><p>High-level: parse the database into $\sqrt N \times \sqrt N$ square, then use matrix-vector multiplication to retrieve one column. Upload and download size are both $\sqrt N$ many $\mathbb{Z}_q$ elements.</p><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20250211021750658.png style=width:70%><figcaption></figcaption></figure></center><p><code>$$ \begin{align*} \mathsf{DB}&: \mathbb{Z}_p^{\sqrt N \times \sqrt N}\\ A &: \mathbb{Z}_q^{\sqrt N \times n}\\ \vec{\mathsf{q_1}} &= A \cdot \vec{s} + \vec{e} + \Delta \vec{\mu_i} = \mathsf{c_2} \text{ in }\mathsf{LWE}(\mu_i)\\ \mathsf{H}&= \mathsf{DB} \times \mathsf{A} \in \mathbb{Z}_q^{\sqrt N \times n} && \text{hint matrix}\\ \mathsf{ans} &= \mathsf{DB} \cdot \vec{\mathsf{q_1}}&& \text{one encrypted column} \end{align*} $$</code></p><p>We can recover the whole column:</p><p><code>$$ \begin{align*} \vec{d'} &= \mathsf{ans} - \mathsf{H} \cdot \vec{s}\\ &= \mathsf{DB} \cdot \vec{\mathsf{q_1}} - (\mathsf{DB} \times A) \cdot \vec{s}\\ &= \mathsf{DB} \cdot (A\cdot \vec{s} + \vec{e} + \Delta \vec{\mu_i}) - \mathsf{DB} \times A \cdot \vec{s}\\ &= \mathsf{DB} \times A\cdot \vec{s} + \mathsf{DB} \cdot \vec{e} + \Delta \cdot \mathsf{DB} \cdot \vec{\mu_i} - \mathsf{DB} \times A \cdot \vec{s}\\ &= \mathsf{DB} \cdot \vec{e} + \Delta \cdot \mathsf{DB} \cdot \vec{\mu_i} \end{align*} $$</code></p><p>Now, you can round this result to closest multiple of $\Delta$, then divide the resulting vector by $\Delta$ to get the retrieved data.</p><h4 id=observation>Observation<a hidden class=anchor aria-hidden=true href=#observation>#</a></h4><ul><li>The time consuming part is $\mathsf{DB} \times A$. However, this is independent to the query and the secrete key. Hence it is used as hint.</li><li>Since we only need one final entry, instead of decrypting the whole answer vector, we can instead use a single row of $H$ and a single $\mathbb{Z}_q$ in $\mathsf{ans}$ for the decryption.</li></ul><h3 id=doublepir>DoublePIR<a hidden class=anchor aria-hidden=true href=#doublepir>#</a></h3><p>Upon decrypting the desired value, the client needs the $j$ th element from $\mathsf{ans} \in \mathbb{Z}_q^{\sqrt N}$, and the $j$ th row of $\mathsf{H} \in \mathbb{Z}_q^{\sqrt N \times n}$. DoublePIR, as suggested in its name, uses another SimplePIR to retrieve these $n + 1$ values. However, with some changes.</p><p>Observe that after running SimplePIR once, $\mathsf{ans}$ and $\mathsf{H_1} := \mathsf{H}$ are all in $\mathbb{Z}_q$. However, the initial input DB for SimplePIR should be in $\mathbb{Z}_p$. Hence, a decomposition function $\mathsf{Decomp}: \mathbb{Z}_q \mapsto \mathbb{Z}_p^{\kappa}$ is used prior to the second SimplePIR, where $\kappa = \lceil \log q/ \log p\rceil$. Now, we treat the decomposed hint $\mathsf{Decomp}(\mathsf{H_1}^T)$ as the new database, we can compute the new hint $\mathsf{H_2} = \mathsf{Decomp}(\mathsf{H_1}^T) \times A_2$, which will be downloaded by the client.</p><p>However, we cannot pre-compute the hint for the $\mathsf{ans}$ vector. Hence, the solution is to create the hint ($\mathsf{H_3} = \mathsf{Decomp}(\mathsf{ans}^T) \times A_2$) and ask the client to download it together with the other $n+1$ values.</p><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20250211021923472.png style=width:90%><figcaption></figcaption></figure></center><h4 id=observation-1>Observation<a hidden class=anchor aria-hidden=true href=#observation-1>#</a></h4><ul><li>The new hint $\mathsf{H_2}$ is only affected by $\kappa$ and $n$. So the hint size won&rsquo;t change when $N$ changes.</li></ul><h3 id=limitations>Limitations<a hidden class=anchor aria-hidden=true href=#limitations>#</a></h3><h4 id=extension-to-large-entries>Extension to large entries<a hidden class=anchor aria-hidden=true href=#extension-to-large-entries>#</a></h4><ul><li>In SimplePIR, hint size is $n \cdot \sqrt{dN}$ many $\mathbb{Z}_q$. For a $1\mathsf{GB}$ database with $4 \mathsf{KB}$ entires, this means $N = 2^{18}, d = 4096 \cdot 8 / 9 \approx 3641, n = 1024$, hint size is roughly $121\mathsf{MB}$</li><li>In DoublePIR, hint size is $d \kappa n^2$ many $\mathbb{Z}_q$. Concretely, this means $16 \mathsf{MB}$ of hint for retreving a $9$-bit entry. If we want to support $4 \mathsf{KB}$ (same as small OnionPIR), hint size will be $16 \cdot d \mathsf{MB} = 58256 \mathsf{MB} \approx 56\mathsf{GB}$.</li><li>Also in DoublePIR, the response size is proportional to $d$. Download $d \cdot \kappa (2n+1)$. In the same $4\mathsf{KB}$ setting, this means $114$ MB for download. So the expansion faction is still an important metric.</li></ul><h4 id=client-side-computation>Client side computation<a hidden class=anchor aria-hidden=true href=#client-side-computation>#</a></h4><p>In the current SimplePIR code base, $A$ is stored and used for creating query. Size of $A$ is same as size of the hint, so in normal setting, 120MB. If we don&rsquo;t store it, then pseudorandomly generating the matrix $A$ takes about $4.5 \mathsf{s}$, while the server computation is in $110\mathsf{ms}$. If we consider this client work for each retrieval, PRG computation will be the dominant factor. This limintation seems to apears in YPIR as well, whose construction was inspired by SimplePIR and DoublePIR.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ofuro.me/tags/cryptography/>Cryptography</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>