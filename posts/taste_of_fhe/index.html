<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Taste of Fully Homomorphic Encryption | Yue's Notes</title>
<meta name=keywords content="cryptography"><meta name=description content="
The following is a note for my talk during Ling&rsquo;s group meeting.

What is FHE?
Homomorphic encryption allows some computation (addition, scalar multiplication, ct-ct multiplication) directly on ciphertexts without first having to decrypt it.
Partially Homomorphic Encryption support only one of those possible operation. RSA is an example:
$$
\text{Enc}(m_1) \cdot \text{Enc}(m_2) = m_1^e \cdot m_2^e = (m_1 \cdot m_2)^e = \text{Enc}(m_1 \cdot m_2)
$$
FHE supports Addition AND Scalar Multiplicaiton:

  
$$
\begin{cases}
\text{Enc}(m_1) + \text{Enc}(m_2) = \text{Enc}(m_1 + m_2)\\
\text{Enc}(m) \cdot c = \text{Enc}(m \cdot c)
\end{cases}
$$



Fancy! And it exsists!"><meta name=author content><link rel=canonical href=https://ofuro.me/posts/taste_of_fhe/><link crossorigin=anonymous href=/assets/css/stylesheet.3f9c3df41d49c1df83c4f93106bd40eae5ce265f122a1a1a99f034136f7c15f5.css integrity="sha256-P5w99B1Jwd+DxPkxBr1A6uXOJl8SKhoamfA0E298FfU=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/taste_of_fhe/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/taste_of_fhe/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="Taste of Fully Homomorphic Encryption"><meta property="og:description" content=" The following is a note for my talk during Ling’s group meeting.
What is FHE? Homomorphic encryption allows some computation (addition, scalar multiplication, ct-ct multiplication) directly on ciphertexts without first having to decrypt it.
Partially Homomorphic Encryption support only one of those possible operation. RSA is an example: $$ \text{Enc}(m_1) \cdot \text{Enc}(m_2) = m_1^e \cdot m_2^e = (m_1 \cdot m_2)^e = \text{Enc}(m_1 \cdot m_2) $$
FHE supports Addition AND Scalar Multiplicaiton: $$ \begin{cases} \text{Enc}(m_1) + \text{Enc}(m_2) = \text{Enc}(m_1 + m_2)\\ \text{Enc}(m) \cdot c = \text{Enc}(m \cdot c) \end{cases} $$ Fancy! And it exsists!"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-18T17:56:58-06:00"><meta property="article:modified_time" content="2024-09-18T17:56:58-06:00"><meta property="article:tag" content="Cryptography"><meta name=twitter:card content="summary"><meta name=twitter:title content="Taste of Fully Homomorphic Encryption"><meta name=twitter:description content="
The following is a note for my talk during Ling&rsquo;s group meeting.

What is FHE?
Homomorphic encryption allows some computation (addition, scalar multiplication, ct-ct multiplication) directly on ciphertexts without first having to decrypt it.
Partially Homomorphic Encryption support only one of those possible operation. RSA is an example:
$$
\text{Enc}(m_1) \cdot \text{Enc}(m_2) = m_1^e \cdot m_2^e = (m_1 \cdot m_2)^e = \text{Enc}(m_1 \cdot m_2)
$$
FHE supports Addition AND Scalar Multiplicaiton:

  
$$
\begin{cases}
\text{Enc}(m_1) + \text{Enc}(m_2) = \text{Enc}(m_1 + m_2)\\
\text{Enc}(m) \cdot c = \text{Enc}(m \cdot c)
\end{cases}
$$



Fancy! And it exsists!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"Taste of Fully Homomorphic Encryption","item":"https://ofuro.me/posts/taste_of_fhe/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Taste of Fully Homomorphic Encryption","name":"Taste of Fully Homomorphic Encryption","description":" The following is a note for my talk during Ling\u0026rsquo;s group meeting.\nWhat is FHE? Homomorphic encryption allows some computation (addition, scalar multiplication, ct-ct multiplication) directly on ciphertexts without first having to decrypt it.\nPartially Homomorphic Encryption support only one of those possible operation. RSA is an example: $$ \\text{Enc}(m_1) \\cdot \\text{Enc}(m_2) = m_1^e \\cdot m_2^e = (m_1 \\cdot m_2)^e = \\text{Enc}(m_1 \\cdot m_2) $$\nFHE supports Addition AND Scalar Multiplicaiton: $$ \\begin{cases} \\text{Enc}(m_1) + \\text{Enc}(m_2) = \\text{Enc}(m_1 + m_2)\\\\ \\text{Enc}(m) \\cdot c = \\text{Enc}(m \\cdot c) \\end{cases} $$ Fancy! And it exsists!\n","keywords":["cryptography"],"articleBody":" The following is a note for my talk during Ling’s group meeting.\nWhat is FHE? Homomorphic encryption allows some computation (addition, scalar multiplication, ct-ct multiplication) directly on ciphertexts without first having to decrypt it.\nPartially Homomorphic Encryption support only one of those possible operation. RSA is an example: $$ \\text{Enc}(m_1) \\cdot \\text{Enc}(m_2) = m_1^e \\cdot m_2^e = (m_1 \\cdot m_2)^e = \\text{Enc}(m_1 \\cdot m_2) $$\nFHE supports Addition AND Scalar Multiplicaiton: $$ \\begin{cases} \\text{Enc}(m_1) + \\text{Enc}(m_2) = \\text{Enc}(m_1 + m_2)\\\\ \\text{Enc}(m) \\cdot c = \\text{Enc}(m \\cdot c) \\end{cases} $$ Fancy! And it exsists!\nLWE \u0026 Ring-LWE Hiding secrets by adding some noise.\nLearning With Error (LWE) Given a random vector $a \\in \\mathbb{Z}_q^n$, a secret key $s \\in \\mathbb{B}^n, \\mathbb{B} = \\set{0, 1}$, a small plaintext message $m \\in \\mathbb{Z}_t$ with $t \\ll q$, and a small noise $e$ sampled from a gaussian distribution centered at 0: $$ \\text{LWE}(m) = (a, a \\cdot s + m + e) $$ $n$ decides the security level we want. The operator “$\\cdot$” is a dot product.\nThe decryption is also straight forward in high-level: $$ \\text{Dec}_s(;(a, b);) = \\lfloor \\varphi_s(;(a, b);)\\rceil = \\lfloor b - a \\cdot s \\rceil $$\nThink of this: if we always encrypt $m = 0$. A “learning without error” scheme can be easily be solved by setting up $n$ linear equations. However, adding this error makes it very hard to solve. (Oded Regev?)\nThe definition I give here is not completely accurate. To encrypt $m$, one should sometimes scale it up or “shift to the left” so that the lower bits are reserved for noise.\nToy example: say $q = 2^{32}$, then we can use a 32 bit unsigned integer for each number. Suppose we allow $m$ to have 4 bits, and the rest $32 - 4 = 28$ lower bits are reserved for our noise.\nAdditions and scalar mulitiplications are intuitive. ct-ct multiplications needs special design. It’s possible!\nBFV is a RLWE scheme that supports ct-ct multiplication. $(a_1, b_1) \\cdot (a_2, b_2) = (a_1b_1, a_1b_2 + a_2b_1, b_1b_2)$.\n#### Supporting larger message? Notice that in the general definition for LWE, the message we can encrypt is $m \\in \\mathbb{Z}_t$. This is typically not enough. What if we want a larger message $\\mu \\in \\mathbb{Z}_t^m$? Hence, we typically use a random matrix $A$ for encryption: $$ \\begin{align*} \\text{LWE}(\\mu) = (A, A \\cdot s + \\mu + e)\\\\ A \\in \\mathbb{Z}_q^{m \\times n}, s \\in \\mathbb{B}^n, \\mu \\in \\mathbb{Z}_t^m \\end{align*} $$ This means that encrypting a vector in $\\mathbb{Z}_t^m$ requires $mn$ many $\\mathbb{Z}_q$. RLWE helps reduce this!\nRing Learning With Error (RLWE) Ring variant of LWE. Instead of having $a$ as a vector, we upgrade all vector addition and scalar multiplication are upgraded to polynomial multiplications and additions. Now, we have $a \\in \\mathbb{Z}_q[x] / (x^n + 1), m \\in \\mathbb{Z}_t[x] / (x^n + 1), s \\in \\mathbb{B}[x] / (x^n + 1)$. $n$ is the polynomial degree. $q$ and $t$ are coefficient modulus for ciphertext and plaintext. Everything in polynoimal!\nRLWE is more efficient: \" LWE problems tend to require rather large key sizes, typically on the order of $n^2$.\" (Regev’s survey) To use LWE, typically need $n$ linear equations with errors, each of them has size $n$ key. In RLWE, you only need $n$ coefficients. Fast Fourier Transform and Number Theoretic Transform can be applied to polynomials. It makes computation faster! The problem with noise growth Addition has additive noise growth, multiplication has multiplicative noise growth. This is bad because we cannot perform this computation many times…\nGood news: there is a way to make multiplications have additive noise growth.\nGadget Decomposition How do you calculate $3405 \\cdot 6$ by hand?\nSimple gadget decomposition (special case):\nFor a message $m \\in \\mathbb{Z}$, we scale it to different powers: $$ \\mathsf{Scale}(m) = m \\cdot (10^{\\ell - 1}, \\ldots, 10^{0}) $$ This creates a vector of size $\\ell$ for some chosen number $\\ell$. Now, if we want to multiply this encrypted message with a constant $C$, we can calculate the inner product between the decomposed C and this scaled value. Just like what we have learnt in primary school. I.e., we can decompose $C$ to $\\text{Decomp}(C) = (C_{\\ell - 1}, \\ldots, C_{0})$such that $$ C = \\sum_{i = 0}^{\\ell -1} C_i 10^i $$ Then the multiplication becomes: $$ C \\cdot m = \\mathsf{Decomp}(C) \\cdot \\mathsf{Scale}(m) $$\nToy Example $m = 6, C = 3405, k = 4$ $$ \\begin{align*} \\text{Decomp}(C) \u0026= (3, 4, 0, 5)\\\\ \\text{Enc}(m) \u0026= (6000, 600, 60, 6) \\\\ C \\cdot m \u0026= 3 \\cdot 6000 + 4 \\cdot 600 + 5 \\cdot 6 = 20430 \\end{align*} $$ Generalization Instead of 10, we can use larger base ($B = 256$ for example). Then the gadget looks like $\\vec{g} = (B^{\\ell - 1}, \\ldots, B^{0})$.\nDenote $g^{-1}(v) := \\mathsf{Decomp}_g(v)$. There is a very good property of gadget decomposition: $$ | g^{-1}(v) \\cdot g - v|_\\infty \\leq \\epsilon $$\nAnother level of generalization looks like: $$ \\begin{align*} G= I_k \\otimes \\vec{g} = \\left(\\begin{array}{c|c|c} B^{\\ell - 1}\u0026 \\ldots \u0026 0 \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ B^0 \u0026 \\ldots \u0026 0 \\\\ \\hline \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\hline 0 \u0026 \\ldots \u0026 B^{\\ell - 1} \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 \\ldots \u0026 B^0 \\end{array}\\right) \\end{align*} $$ It turns out that this big $G$ here is also a gadget by definition 3.1 in Building an Efficient Lattice Gadget Toolkit: Subgaussian Sampling and More if we treat each row as an element.\nRing-GSW This is another FHE scheme. The special thing about this scheme is that it uses RLWE and a special gadget matrix during the encryption stage. $$ \\begin{align*} \\text{RGSW}(m) = Z + m \\cdot G \u0026\u0026 Z = (\\underbrace{\\text{RLWE}(0), \\ldots, \\text{RLWE}(0)}_{2 \\ell}), G = I_2 \\otimes \\vec{g} \\end{align*} $$ This is a Ring-GSW sample that encrypts the message $m$ (without scaling by any factor). This is a special case of RGSW (otherwise $G = I_k \\otimes \\vec{g}$ for any desired $k$. Check TFHE). And, we also have $2\\ell$ rows of RLWE(0). This encryption is straight forward. However, I don’t know any decryption methods. Why? Note that some gadget values are very small compared to the ciphertext coefficient modulus, which means $m \\cdot g_i$ can be as small as the noise…\nExternal Product Additive noise growth for ct-ct multiplication!!!\nExternal product using only one gadget decomposition: $$ \\begin{align*} \\text{RGSW} \\boxdot \\text{RLWE} \u0026\\to \\text{RLWE} \\\\ (A, b) \u0026\\mapsto A \\boxdot b = G^{-1}(b) \\cdot A \\end{align*} $$ English: we first decompose the RLWE ciphertext, and then multiply it with RGSW.\nIn the context of external product, $\\text{Decomp}_G(v) \\in R^{1\\times2l}, A \\in R^{2l \\times 2}$.\nProof sketch Let $\\text{msg}(A) = \\mu_A, \\text{msg}(b) = \\mu_b$. By definition of RLWE, $b = (a, a \\cdot s + \\mu_b + e) = (a, a \\cdot s + 0 + e) + (0, \\mu_b) = z_b + (0, \\mu_b)$. $$ \\begin{align*} A \\boxdot b \u0026= G^{-1}(b) \\cdot A = G^{-1}(b) \\cdot (Z_A + \\mu_A \\cdot G)\\\\ \u0026= G^{-1}(b) \\cdot Z_A + \\mu_A \\cdot (G^{-1}(b) \\cdot G)\\\\ \u0026= G^{-1}(b) \\cdot Z_A + \\mu_A \\cdot (\\epsilon + b)\\\\ \u0026= G^{-1}(b) \\cdot Z_A + \\mu_A \\cdot \\epsilon + \\mu_A \\cdot (z_b + (0, \\mu_b))\\\\ \u0026= G^{-1}(b) \\cdot Z_A + \\mu_A \\cdot \\epsilon + \\mu_A \\cdot z_b + (0, \\mu_A \\cdot \\mu_b)\\\\ \\end{align*} $$ Decryption is to calculate the linear equation $\\varphi_s(;(a, b);) = b - a \\cdot s$. Then, rounding the result, everything goes to zero except $\\mu_A \\cdot \\mu_b$.\nWhy this is good? Check the noise growth! The advantage for doing this is the first term $G^{-1}(b) \\cdot A$. If we don’t do the gadget decomposition, say $G^{-1}(b) = b$, and $A$ is a vector, then this term multiplies the error of two messages together. However, because of the gadget decomposition, the error term inside $b$ is upper bounded by $B$. The total error looks like:\n$$ \\begin{align*} \\| \\text{Err}(A \\boxdot b) \\|_\\infty\\leq \\| G^{-1}(b) \\cdot \\text{Err}(A) \\|_\\infty + |\\mu_A| \\cdot \\epsilon + |\\mu_A| \\cdot \\text{Err}(b)\\\\ \\text{Roughly: } O(B \\cdot \\text{Err}(A) + |\\mu_A| \\cdot \\text{Err}(b)) \\end{align*} $$ If we have small message $\\mu_A$, then this multiplication is roughly free! I must quote this sentence I learnt from Jeremy Kun: “This is useful when the noise growth is asymmetric in the two arguments, and so basically you make the noise-heavy part as small as possible and move the powers of 2 to the other side.”\nThe essence is that we separate RLWE, which is very sensitive to scaling, to smaller parts, and then perform this “digit-by-digit” multiplication. We can do this because we have carefully designed this RGSW scheme so that it stores enough information for all powers of $B$, saving this scaling for RLWE.\nKey Switching In RLWE, key switching is a technique that helps us change the underlying secret key without decrypting the ciphertext. Formally, we want to change the underlying secret key from $s$ to $t$: $$ \\begin{align*} c = (a, b) \\;\\;\\; \u0026\\longrightarrow \\;\\;\\; c' = (a', b')\\\\ c = (a, a \\cdot s + m + e) \\;\\;\\; \u0026\\longrightarrow \\;\\;\\; c' = (a', a' \\cdot t + m + e')\\\\ \\end{align*} $$ Definition Key Switching Key(KSK) $$ \\mathsf{KSK}(s, t) = \\mathsf{RLWE}t(s) = (x, x \\cdot t + s + e{\\text{new}}) $$ where $x \\in \\mathbb{Z}_q[X] / (x^n + 1)$ is another random polynomial. This is a new ciphertext encrypting the old secret key.\nThen, the new ciphertext $c’$ can be computed by: $$ \\begin{align*} c' \u0026= (0, b) - a \\mathsf{KSK} \\\\ \u0026= (0, b) - (a x, a (x t + s + e_{\\text{new}}))\\\\ \u0026= -(ax, (a x t + a s + a e_{\\text{new}}) - b)\\\\ \u0026= -(ax, (a x t + a s + a e_{\\text{new}}) - (as + m + e))\\\\ \u0026= (-ax, -a x t + m + (e - ae_{\\text{new}}))\\\\ \u0026= (a', a't + m + e') \\end{align*} $$ Observe that this is still a valid RLWE ciphertext. Here is another way to to check if $c’$ has correctly encrypted the message $m$ under the key $t$. We check this by applying the phase function (or simply decrypt it): $$ \\begin{align*} \\varphi_t(c') \u0026= \\varphi_t(\\; (0, b) - a \\cdot \\mathsf{KSK}\\;)\\\\ \u0026= \\varphi_t((0, b)) - a \\cdot \\varphi_t(\\mathsf{KSK})\\\\ \u0026= (b - 0 \\cdot t) - a \\cdot (s + e_{\\text{new}})\\\\ \u0026= (b - a \\cdot s) - a \\cdot e_{\\text{new}}\\\\ \u0026= m + e - a \\cdot e_{\\text{new}}\\\\ \\end{align*} $$ This is consistant with the aboved result.\nHOWEVER, the error $a \\cdot e_\\text{new}$ can be too large! $a$ is randomly sampled in $\\mathbb{Z}_q[X] / (x^n + 1)$. The trick is to use Gadget Decomposition! Decomposing $a$ into smaller chunks, and scaling the underlying message inside KSK into different levels, without scaling up the error. $$ \\begin{align*} \u0026\\text{Scaling this up: }\\mathsf{KSK}(s, t)'_i = \\mathsf{RLWE}_t^*(sB^i) = (x, x \\cdot t + sB_i + e_{\\text{new}}), i = 0, \\ldots, \\ell - 1\\\\ \u0026\\text{Decomposing this: }a \\Rightarrow G^{-1}(a) = \\set{a_i : i = 0, \\ldots l-1} \\end{align*} $$ The new ciphertext is computed: $$ \\begin{align*} c' \u0026= (0, b) - G^{-1}(a) \\cdot \\mathsf{KSK}(s, t)'\\\\ \u0026= (0, b) - \\sum_{i = 0}^{\\ell-1}G^{-1}(a)_i \\cdot \\mathsf{KSK}(s, t)'_i \\end{align*} $$ Check the phase of this ciphertext: $$ \\begin{align*} \\varphi_t(c') \u0026= \\varphi(0, b) - \\sum_{i = 0}^{\\ell-1}G^{-1}(a)_i \\cdot \\varphi_t \\left( \\mathsf{KSK}(s, t)'_i \\right)\\\\ \u0026= b - \\sum_{i = 0}^{\\ell - 1} G^{-1}(a) \\cdot (sB_i + e_i)\\\\ \u0026= b - s \\cdot (G^{-1}(a) \\cdot G) - \\sum_{i = 0}^{\\ell - 1}\\underbrace{G^{-1}(a)}_{\\mathcal{O}(B)} \\cdot e_i\\\\ \u0026= b - a \\cdot s + e' \\end{align*} $$ Substitution / Frobenius Automorphism The underlying $X$ is multiplied by $k$. So the term $X^i \\mapsto X^{ik}$: $$ \\mathsf{Subs}(\\mathsf{RLWE}(\\mu(X)), k) = \\mathsf{RLWE}(\\mu(X^k)) $$ This can be implemented using the key switching algorithm.\nEssence: to apply the Frobenius automorphism on the message, we have to apply it to the whole ciphertext. But we can use a new key $s(X^k)$ to replace $s(X)$ to cancel the changes in the random part $a(X) \\mapsto a(X^k)$. Then, decrypting the message leaves only the message $\\mu(X^k)$. We don’t care the error term because the variance of the error is not changed.\nReferences: I found Jeremy Kun recently. He had some amazing blogs on FHE:\nA High-Level Technical Overview of Fully Homomorphic Encryption\nThe Gadget Decomposition in FHE\nKey Switching in LWE\nTFHE: Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds\nWiki pages:\nRSA\nHomomorphic Encryption\nLearning with errors\nFirst LWE: On lattices, learning with errors, random linear codes, and cryptography\nGadget: Building an Efficient Lattice Gadget Toolkit: Subgaussian Sampling and More\nOnion-Ring ORAM\nO. Regev, “The Learning with Errors Problem (Invited Survey),” 2010 IEEE 25th Annual Conference on Computational Complexity, Cambridge, MA, USA, 2010, pp. 191-204, doi: 10.1109/CCC.2010.26.\n","wordCount":"2115","inLanguage":"en","datePublished":"2024-09-18T17:56:58-06:00","dateModified":"2024-09-18T17:56:58-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/taste_of_fhe/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/ title=Notes><span>Notes</span></a></li><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Taste of Fully Homomorphic Encryption</h1><div class=post-meta><span title='2024-09-18 17:56:58 -0600 -0600'>September 18, 2024</span></div></header><div class=post-content><blockquote><p>The following is a note for my talk during Ling&rsquo;s group meeting.</p></blockquote><h3 id=what-is-fhe>What is FHE?<a hidden class=anchor aria-hidden=true href=#what-is-fhe>#</a></h3><p>Homomorphic encryption allows some computation (addition, scalar multiplication, ct-ct multiplication) directly on ciphertexts without first having to decrypt it.</p><p>Partially Homomorphic Encryption support only one of those possible operation. RSA is an example:
$$
\text{Enc}(m_1) \cdot \text{Enc}(m_2) = m_1^e \cdot m_2^e = (m_1 \cdot m_2)^e = \text{Enc}(m_1 \cdot m_2)
$$</p><p>FHE supports Addition AND Scalar Multiplicaiton:<div>$$
\begin{cases}
\text{Enc}(m_1) + \text{Enc}(m_2) = \text{Enc}(m_1 + m_2)\\
\text{Enc}(m) \cdot c = \text{Enc}(m \cdot c)
\end{cases}
$$</div>Fancy! And it exsists!</p><h3 id=lwe--ring-lwe>LWE & Ring-LWE<a hidden class=anchor aria-hidden=true href=#lwe--ring-lwe>#</a></h3><blockquote><p>Hiding secrets by adding some noise.</p></blockquote><h4 id=learning-with-error-lwe>Learning With Error (LWE)<a hidden class=anchor aria-hidden=true href=#learning-with-error-lwe>#</a></h4><p>Given a random vector $a \in \mathbb{Z}_q^n$, a secret key $s \in \mathbb{B}^n, \mathbb{B} = \set{0, 1}$, a small plaintext message $m \in \mathbb{Z}_t$ with $t \ll q$, and a small noise $e$ sampled from a gaussian distribution centered at 0:
$$
\text{LWE}(m) = (a, a \cdot s + m + e)
$$
$n$ decides the security level we want. The operator &ldquo;$\cdot$&rdquo; is a dot product.</p><p>The decryption is also straight forward in high-level:
$$
\text{Dec}_s(;(a, b);) = \lfloor \varphi_s(;(a, b);)\rceil = \lfloor b - a \cdot s \rceil
$$</p><p>Think of this: if we always encrypt $m = 0$. A &ldquo;learning without error&rdquo; scheme can be easily be solved by setting up $n$ linear equations. However, adding this error makes it very hard to solve. (Oded Regev?)</p><blockquote><p>The definition I give here is not completely accurate. To encrypt $m$, one should sometimes scale it up or &ldquo;shift to the left&rdquo; so that the lower bits are reserved for noise.</p><p><strong>Toy example</strong>: say $q = 2^{32}$, then we can use a 32 bit unsigned integer for each number. Suppose we allow $m$ to have 4 bits, and the rest $32 - 4 = 28$ lower bits are reserved for our noise.</p></blockquote><p>Additions and scalar mulitiplications are intuitive. ct-ct multiplications needs special design. It&rsquo;s possible!</p><p>BFV is a RLWE scheme that supports ct-ct multiplication. $(a_1, b_1) \cdot (a_2, b_2) = (a_1b_1, a_1b_2 + a_2b_1, b_1b_2)$.</p><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240823015931470.png style=width:70%><figcaption></figcaption></figure></center>#### Supporting larger message?<p>Notice that in the general definition for LWE, the message we can encrypt is $m \in \mathbb{Z}_t$. This is typically not enough. What if we want a larger message $\mu \in \mathbb{Z}_t^m$? Hence, we typically use a random matrix $A$ for encryption:<div>$$
\begin{align*}
\text{LWE}(\mu) = (A, A \cdot s + \mu + e)\\
A \in \mathbb{Z}_q^{m \times n}, s \in \mathbb{B}^n, \mu \in \mathbb{Z}_t^m
\end{align*}
$$</div>This means that encrypting a vector in $\mathbb{Z}_t^m$ requires $mn$ many $\mathbb{Z}_q$. RLWE helps reduce this!</p><h4 id=ring-learning-with-error-rlwe>Ring Learning With Error (RLWE)<a hidden class=anchor aria-hidden=true href=#ring-learning-with-error-rlwe>#</a></h4><p>Ring variant of LWE. Instead of having $a$ as a vector, we upgrade all vector addition and scalar multiplication are upgraded to polynomial multiplications and additions. Now, we have $a \in \mathbb{Z}_q[x] / (x^n + 1), m \in \mathbb{Z}_t[x] / (x^n + 1), s \in \mathbb{B}[x] / (x^n + 1)$. $n$ is the polynomial degree. $q$ and $t$ are coefficient modulus for ciphertext and plaintext. Everything in polynoimal!</p><h4 id=rlwe-is-more-efficient>RLWE is more efficient:<a hidden class=anchor aria-hidden=true href=#rlwe-is-more-efficient>#</a></h4><ul><li>" LWE problems tend to require rather large key sizes, typically on the order of $n^2$." (Regev&rsquo;s survey) To use LWE, typically need $n$ linear equations with errors, each of them has size $n$ key. In RLWE, you only need $n$ coefficients.</li><li>Fast Fourier Transform and Number Theoretic Transform can be applied to polynomials. It makes computation faster!</li></ul><h4 id=the-problem-with-noise-growth>The problem with noise growth<a hidden class=anchor aria-hidden=true href=#the-problem-with-noise-growth>#</a></h4><p>Addition has additive noise growth, multiplication has multiplicative noise growth. This is bad because we cannot perform this computation many times&mldr;</p><p>Good news: there is a way to make multiplications have additive noise growth.</p><h3 id=gadget-decomposition>Gadget Decomposition<a hidden class=anchor aria-hidden=true href=#gadget-decomposition>#</a></h3><blockquote><p>How do you calculate $3405 \cdot 6$ by hand?</p></blockquote><p>Simple gadget decomposition (special case):</p><p>For a message $m \in \mathbb{Z}$, we scale it to different powers:
$$
\mathsf{Scale}(m) = m \cdot (10^{\ell - 1}, \ldots, 10^{0})
$$
This creates a vector of size $\ell$ for some chosen number $\ell$. Now, if we want to multiply this encrypted message with a constant $C$, we can calculate the inner product between the decomposed C and this scaled value. Just like what we have learnt in primary school. I.e., we can decompose $C$ to $\text{Decomp}(C) = (C_{\ell - 1}, \ldots, C_{0})$such that
$$
C = \sum_{i = 0}^{\ell -1} C_i 10^i
$$
Then the multiplication becomes:
$$
C \cdot m = \mathsf{Decomp}(C) \cdot \mathsf{Scale}(m)
$$</p><h4 id=toy-example>Toy Example<a hidden class=anchor aria-hidden=true href=#toy-example>#</a></h4><p>$m = 6, C = 3405, k = 4$<div>$$
\begin{align*}
\text{Decomp}(C) &= (3, 4, 0, 5)\\
\text{Enc}(m) &= (6000, 600, 60, 6) \\
C \cdot m &= 3 \cdot 6000  + 4 \cdot 600 +  5 \cdot 6 = 20430
\end{align*}
$$</div></p><h4 id=generalization>Generalization<a hidden class=anchor aria-hidden=true href=#generalization>#</a></h4><p>Instead of 10, we can use larger base ($B = 256$ for example). Then the gadget looks like $\vec{g} = (B^{\ell - 1}, \ldots, B^{0})$.</p><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240823023737653.png style=width:100%><figcaption></figcaption></figure></center><p>Denote $g^{-1}(v) := \mathsf{Decomp}_g(v)$. There is a very good property of gadget decomposition:
$$
| g^{-1}(v) \cdot g - v|_\infty \leq \epsilon
$$</p><p>Another level of generalization looks like:<div>$$
\begin{align*}
G= I_k \otimes \vec{g} =
\left(\begin{array}{c|c|c}
B^{\ell - 1}& \ldots & 0 \\
\vdots & \ddots & \vdots \\
B^0 & \ldots & 0 \\
\hline \vdots & \ddots & \vdots \\
\hline 0 & \ldots & B^{\ell - 1} \\
\vdots & \ddots & \vdots \\
0 & \ldots & B^0
\end{array}\right)
\end{align*}
$$</div>It turns out that this big $G$ here is also a gadget by definition 3.1 in <a href=https://eprint.iacr.org/2018/946.pdf>Building an Efficient Lattice Gadget Toolkit: Subgaussian Sampling and More</a> if we treat each row as an element.</p><h3 id=ring-gsw>Ring-GSW<a hidden class=anchor aria-hidden=true href=#ring-gsw>#</a></h3><p>This is another FHE scheme. The special thing about this scheme is that it uses RLWE and a special gadget matrix during the encryption stage.<div>$$
\begin{align*}
\text{RGSW}(m) = Z + m \cdot G && 
Z = (\underbrace{\text{RLWE}(0), \ldots, \text{RLWE}(0)}_{2 \ell}), G = I_2 \otimes \vec{g}
\end{align*}
$$</div>This is a Ring-GSW sample that encrypts the message $m$ (without scaling by any factor). This is a special case of RGSW (otherwise $G = I_k \otimes \vec{g}$ for any desired $k$. Check <a href=https:/print.iacr.org/2016/870>TFHE</a>). And, we also have $2\ell$ rows of RLWE(0). This encryption is straight forward. However, I don&rsquo;t know any decryption methods. Why? Note that some gadget values are very small compared to the ciphertext coefficient modulus, which means $m \cdot g_i$ can be as small as the noise&mldr;</p><h3 id=external-product>External Product<a hidden class=anchor aria-hidden=true href=#external-product>#</a></h3><blockquote><p>Additive noise growth for ct-ct multiplication!!!</p></blockquote><p>External product using only one gadget decomposition:<div>$$
\begin{align*}
\text{RGSW} \boxdot \text{RLWE} &\to \text{RLWE} \\
(A, b) &\mapsto A \boxdot b = G^{-1}(b) \cdot A
\end{align*}
$$</div>English: we first decompose the RLWE ciphertext, and then multiply it with RGSW.</p><blockquote><p>In the context of external product, $\text{Decomp}_G(v) \in R^{1\times2l}, A \in R^{2l \times 2}$.</p></blockquote><h4 id=proof-sketch>Proof sketch<a hidden class=anchor aria-hidden=true href=#proof-sketch>#</a></h4><p>Let $\text{msg}(A) = \mu_A, \text{msg}(b) = \mu_b$. By definition of RLWE, $b = (a, a \cdot s + \mu_b + e) = (a, a \cdot s + 0 + e) + (0, \mu_b) = z_b + (0, \mu_b)$.<div>$$
\begin{align*}
A \boxdot b &= G^{-1}(b) \cdot A = G^{-1}(b) \cdot (Z_A + \mu_A \cdot G)\\
&= G^{-1}(b) \cdot Z_A + \mu_A \cdot (G^{-1}(b) \cdot G)\\
&= G^{-1}(b) \cdot Z_A + \mu_A \cdot (\epsilon + b)\\
&= G^{-1}(b) \cdot Z_A + \mu_A \cdot \epsilon + \mu_A \cdot (z_b + (0, \mu_b))\\
&= G^{-1}(b) \cdot Z_A + \mu_A \cdot \epsilon + \mu_A \cdot z_b + (0, \mu_A \cdot \mu_b)\\
\end{align*}
$$</div></p><p>Decryption is to calculate the linear equation $\varphi_s(;(a, b);) = b - a \cdot s$. Then, rounding the result, everything goes to zero except $\mu_A \cdot \mu_b$.</p><h4 id=why-this-is-good>Why this is good?<a hidden class=anchor aria-hidden=true href=#why-this-is-good>#</a></h4><p>Check the noise growth! The advantage for doing this is the first term $G^{-1}(b) \cdot A$. If we don&rsquo;t do the gadget decomposition, say $G^{-1}(b) = b$, and $A$ is a vector, then this term multiplies the error of two messages together. However, because of the gadget decomposition, the error term inside $b$ is upper bounded by $B$. The total error looks like:</p><div>$$
\begin{align*}
\| \text{Err}(A \boxdot b) \|_\infty\leq
\| G^{-1}(b) \cdot \text{Err}(A) \|_\infty + |\mu_A| \cdot \epsilon + |\mu_A| \cdot \text{Err}(b)\\
\text{Roughly: } O(B \cdot \text{Err}(A) + |\mu_A| \cdot \text{Err}(b))
\end{align*}
$$</div><p>If we have small message $\mu_A$, then this multiplication is roughly free! I must quote this sentence I learnt from Jeremy Kun: &ldquo;This is useful when the noise growth is asymmetric in the two arguments, and so basically you make the noise-heavy part as small as possible and move the powers of 2 to the other side.&rdquo;</p><p>The essence is that we separate RLWE, which is very sensitive to scaling, to smaller parts, and then perform this &ldquo;digit-by-digit&rdquo; multiplication. We can do this because we have carefully designed this RGSW scheme so that it stores enough information for all powers of $B$, saving this scaling for RLWE.</p><hr><h3 id=key-switching>Key Switching<a hidden class=anchor aria-hidden=true href=#key-switching>#</a></h3><p>In RLWE, key switching is a technique that helps us change the underlying secret key without decrypting the ciphertext. Formally, we want to change the underlying secret key from $s$ to $t$:<div>$$
\begin{align*}
c = (a, b) \;\;\; &\longrightarrow \;\;\; c' = (a', b')\\
c = (a, a \cdot s + m + e) \;\;\; &\longrightarrow \;\;\; c' = (a', a' \cdot t + m + e')\\
\end{align*}
$$</div><span style=color:#28a745>Definition</span> Key Switching Key(KSK)
$$
\mathsf{KSK}(s, t) = \mathsf{RLWE}<em>t(s) = (x, x \cdot t + s + e</em>{\text{new}})
$$
where $x \in \mathbb{Z}_q[X] / (x^n + 1)$ is another random polynomial. This is a new ciphertext encrypting the old secret key.</p><p>Then, the new ciphertext $c&rsquo;$ can be computed by:<div>$$
\begin{align*}
c' &= (0, b) - a \mathsf{KSK} \\
&= (0, b) - (a x, a (x t + s + e_{\text{new}}))\\
&= -(ax, (a x t + a s + a e_{\text{new}}) - b)\\
&= -(ax, (a x t + a s + a e_{\text{new}}) - (as + m + e))\\
&= (-ax, -a x t + m + (e - ae_{\text{new}}))\\
&= (a', a't + m + e')
\end{align*}
$$</div>Observe that this is still a valid RLWE ciphertext. Here is another way to to check if $c&rsquo;$ has correctly encrypted the message $m$ under the key $t$. We check this by applying the phase function (or simply decrypt it):<div>$$
\begin{align*}
\varphi_t(c') &= \varphi_t(\; (0, b) - a \cdot \mathsf{KSK}\;)\\
&= \varphi_t((0, b)) - a \cdot \varphi_t(\mathsf{KSK})\\
&= (b - 0 \cdot t) - a \cdot (s + e_{\text{new}})\\
&= (b - a \cdot s) - a \cdot e_{\text{new}}\\
&= m + e - a \cdot e_{\text{new}}\\
\end{align*}
$$</div>This is consistant with the aboved result.</p><p><strong>HOWEVER</strong>, the error $a \cdot e_\text{new}$ can be too large! $a$ is randomly sampled in $\mathbb{Z}_q[X] / (x^n + 1)$. The trick is to use Gadget Decomposition! Decomposing $a$ into smaller chunks, and scaling the underlying message inside KSK into different levels, without scaling up the error.<div>$$
\begin{align*}
&\text{Scaling this up: }\mathsf{KSK}(s, t)'_i = \mathsf{RLWE}_t^*(sB^i) = (x, x \cdot t + sB_i + e_{\text{new}}), i = 0, \ldots, \ell - 1\\
&\text{Decomposing this: }a \Rightarrow G^{-1}(a) = \set{a_i : i = 0, \ldots l-1}
\end{align*}
$$</div>The new ciphertext is computed:<div>$$
\begin{align*}
c' &= (0, b) - G^{-1}(a) \cdot \mathsf{KSK}(s, t)'\\
&= (0, b) - \sum_{i = 0}^{\ell-1}G^{-1}(a)_i \cdot \mathsf{KSK}(s, t)'_i
\end{align*}
$$</div>Check the phase of this ciphertext:<div>$$
\begin{align*}
\varphi_t(c') &= \varphi(0, b) - \sum_{i = 0}^{\ell-1}G^{-1}(a)_i \cdot \varphi_t
\left( \mathsf{KSK}(s, t)'_i \right)\\
&= b - \sum_{i = 0}^{\ell - 1} G^{-1}(a) \cdot (sB_i + e_i)\\
&= b - s \cdot (G^{-1}(a) \cdot G) - \sum_{i = 0}^{\ell - 1}\underbrace{G^{-1}(a)}_{\mathcal{O}(B)} \cdot e_i\\
&= b - a \cdot s + e'
\end{align*}
$$</div></p><h4 id=substitution--frobenius-automorphism>Substitution / Frobenius Automorphism<a hidden class=anchor aria-hidden=true href=#substitution--frobenius-automorphism>#</a></h4><p>The underlying $X$ is multiplied by $k$. So the term $X^i \mapsto X^{ik}$:
$$
\mathsf{Subs}(\mathsf{RLWE}(\mu(X)), k) = \mathsf{RLWE}(\mu(X^k))
$$
This can be implemented using the key switching algorithm.</p><p>Essence: to apply the Frobenius automorphism on the message, we have to apply it to the whole ciphertext. But we can use a new key $s(X^k)$ to replace $s(X)$ to cancel the changes in the random part $a(X) \mapsto a(X^k)$. Then, decrypting the message leaves only the message $\mu(X^k)$. We don&rsquo;t care the error term because the variance of the error is not changed.</p><hr><h3 id=references>References:<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><ul><li><p>I found <a href=https://www.jeremykun.com/about/>Jeremy Kun</a> recently. He had some amazing blogs on FHE:</p><ul><li><p><a href=https://www.jeremykun.com/2024/05/04/fhe-overview/#gadget-decompositions>A High-Level Technical Overview of Fully Homomorphic Encryption</a></p></li><li><p><a href=https://www.jeremykun.com/2021/12/11/the-gadget-decomposition-in-fhe/>The Gadget Decomposition in FHE</a></p></li><li><p><a href=https://www.jeremykun.com/2022/08/29/key-switching-in-lwe/>Key Switching in LWE</a></p></li></ul></li><li><p>TFHE: <a href=https:/print.iacr.org/2016/870>Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds</a></p></li><li><p>Wiki pages:</p><ul><li><p><a href=https://en.wikipedia.org/wiki/RSA_(cryptosystem)>RSA</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/Homomorphic_encryption>Homomorphic Encryption</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/Learning_with_errors#Use_in_cryptography>Learning with errors</a></p></li></ul></li><li><p>First LWE: <a href=https://dl.acm.org/doi/10.1145/1060590.1060603>On lattices, learning with errors, random linear codes, and cryptography</a></p></li><li><p>Gadget: <a href=https://eprint.iacr.org/2018/946.pdf>Building an Efficient Lattice Gadget Toolkit: Subgaussian Sampling and More</a></p></li><li><p><a href=https://eprint.iacr.org/2019/736>Onion-Ring ORAM</a></p></li><li><p>O. Regev, &ldquo;The Learning with Errors Problem (Invited Survey),&rdquo; 2010 IEEE 25th Annual Conference on Computational Complexity, Cambridge, MA, USA, 2010, pp. 191-204, doi: 10.1109/CCC.2010.26.</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://ofuro.me/tags/cryptography/>Cryptography</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>