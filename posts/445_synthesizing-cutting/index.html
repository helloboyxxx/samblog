<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>445_Synthesizing and Cutting | Yue's Notes</title>
<meta name=keywords content="Computational Photography"><meta name=description content="Texture Synthesis and Hole-Filling

How do we cut something out of an image, and fill the hole naturally?

Definition Texture depicts spacially repeating patterns.
Texture Synthesis
Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:

Compute statistics of input texture
Generate a new texture that keeps those same statistics.

But it is hard to model those probabilities distributions."><meta name=author content><link rel=canonical href=https://ofuro.me/posts/445_synthesizing-cutting/><link crossorigin=anonymous href=/assets/css/stylesheet.6a49f6cf4a2bdda56a77391d7f5624ae4f617195770e1d3dfe5d3a759ad98336.css integrity="sha256-akn2z0or3aVqdzkdf1Ykrk9hcZV3Dh09/l06dZrZgzY=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/445_synthesizing-cutting/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/445_synthesizing-cutting/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="445_Synthesizing and Cutting"><meta property="og:description" content="Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?
Definition Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-30T10:33:26-05:00"><meta property="article:modified_time" content="2023-10-30T10:33:26-05:00"><meta property="article:tag" content="Computational Photography"><meta name=twitter:card content="summary"><meta name=twitter:title content="445_Synthesizing and Cutting"><meta name=twitter:description content="Texture Synthesis and Hole-Filling

How do we cut something out of an image, and fill the hole naturally?

Definition Texture depicts spacially repeating patterns.
Texture Synthesis
Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:

Compute statistics of input texture
Generate a new texture that keeps those same statistics.

But it is hard to model those probabilities distributions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"445_Synthesizing and Cutting","item":"https://ofuro.me/posts/445_synthesizing-cutting/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"445_Synthesizing and Cutting","name":"445_Synthesizing and Cutting","description":"Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?\nDefinition Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.\n","keywords":["Computational Photography"],"articleBody":"Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?\nDefinition Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.\nAnother idea: ==Efros \u0026 Leung algorithm==\nGiven the neighbour, we want to calculate the probabiliy of appearing this pixel $p$ in the middle.\nHow to match pixels?\nGaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels. \\begin{align*} \\text{SSD}(P, Q) = \\sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\\\\ \\text{where } w_{ij} = e^{ \\frac{-(1-w/2)^2 - (j - h/2)^2}{2 \\sigma^2} } \\end{align*}\nwhere $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.\nWhat order to fill in new pixels?\n“Onion skin” order: pixels with most neighbors are synthesized first. How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.\nTexture synthesis algorithm While image not filled:\nGet unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?) For each pixel, get top N matches based on visible neighbors. This is where we use the Gaussian-weighted SSD. Randomly select one of the matches and copy pixels from it. This algorithm can be used for hole filling, extrapolation, …\nHole-Filling We can just use the texture synthesis algorithm.BUT, the order of filling matters.\nSometimes, we can add more weights for the continuous edges when peforming the onion filling. (Gradient sensitive). It makes the edges to be more intact.\nWe want it to be faster The Efros \u0026 Leung texture synthesis algorithm is simple and good, but too slow…\nThe next iteration is: Image quilting (Efros \u0026 Freeman 2001).\nIt depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.\nWe need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra’s algorithm, we can easy calculate what we want.\nTexture Transfer Very similar to texture synthesis, but in a more restricted condition: $$ \\text{cost} = \\alpha * \\text{SSD}{overlap} + (1-\\alpha)* \\text{SSD}{transfer} $$\nImage Analogies Intelligent Scissors and Graph Cuts We want to find seams and boundaries. Then, CUT!\nFundamental Concepts: The image as a Graph\nIntelligent Scissers: Good boundary = short path Graph cuts: Good region has low cutting cost. The goal ofSemi-automated segmentation: User provides imprecise and incomplete specification of region — your algorithm has to read his/her mind.\nA good region:\nContains small range of color/ texture. Looks different than background Compact A good boundary:\nHigh gradient along boundary Gradient in right direction Smooth CS445 Hoiem. Good Region and good boundary. Intelligent Scissors Consider these image as a graph. Think of pixels as nodes, and think of cost of the path between two pixels as weighted edges.\nIntelligent Scissors. Mortenson and Barrett (SIGGRAPH 1995) Using this model, a **good boundary** of an image has a short path through the graph. Formulation: find good boundary between seed points.\nChallenges:\nMinimize interaction time Define what makes a good boundary Efficienctly find it Luckily, these can be achieved by using Dijkstra’s algorithm with a properly defined graph.\nIntelligent Scissors method Define boundary cost between neighboring pixels\nLower if edge is present\nLower is gradient is strong\nLower if gradient is in direction of boundary\nUser specifies a starting point (seed)\nA little snapping to the edges makes pixel-perfect operation not neccessary. Compute lowest cost from seed to each other pixel\nDijkstra’s shortest path algorithm Get path from seed to cursor, choose new seed, repeat\nUsing this boundary cost, the path tends to follow the edges of objects. It makes the algorithm works. Dijkstra’s algorithm makes it fast.\nGraph Cuts CS445 Hoiem Look at the energe function, $y$ in the function represents the label of pixels (whether they belong to label 0 or 1). And, there are two kinds of cost.\nThe first one is the unary cost, it measures whether the pixel is more similar to label 0 or 1. The second one is a pair wise cose, which allows groups of pixels to be assigned to the same label. The goal of the graph cut algorithm is to find a cut through the graph to seperate the foreground and the background.\nThe Graph Cut Segmentation algorithm: Define graph usually 4-connected or 8-connected Set weights to foreground/background Color histogram or mixture of Gaussians for background and foreground. More foreground tends to be negative. $$ \\textit { unary_ potential }(x)=-\\log \\left(\\frac{P\\left(c(x) ; \\theta_{\\text {foreground }}\\right)}{P\\left(c(x) ; \\theta_{\\text {background }}\\right)}\\right) $$ 3. Set weights for edges between pixels\n$$ \\textit { edge_ potential }(x, y)=k_1+k_2 \\exp\\left{ \\frac{-|c(x)-c(y)|^2}{2 \\sigma^2} \\right} $$\nApply min-cut/max-flow algorithm foreground, background models Return to 2, using current labels to compute foreground, background models. Limitations of Graph Cut Requires associative graphs Connected notes should prefer to have the same label Is optimal only for binary problems Reference CS445 Derek Hoiem: https://courses.engr.illinois.edu/cs445/fa2023/\n","wordCount":"894","inLanguage":"en","datePublished":"2023-10-30T10:33:26-05:00","dateModified":"2023-10-30T10:33:26-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/445_synthesizing-cutting/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">445_Synthesizing and Cutting</h1><div class=post-meta><span title='2023-10-30 10:33:26 -0500 -0500'>October 30, 2023</span></div></header><div class=post-content><h2 id=texture-synthesis-and-hole-filling>Texture Synthesis and Hole-Filling<a hidden class=anchor aria-hidden=true href=#texture-synthesis-and-hole-filling>#</a></h2><blockquote><p>How do we cut something out of an image, and fill the hole naturally?</p></blockquote><p><span style=color:#28a745>Definition</span> Texture depicts spacially repeating patterns.</p><h3 id=texture-synthesis>Texture Synthesis<a hidden class=anchor aria-hidden=true href=#texture-synthesis>#</a></h3><p>Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.</p><p><strong>The challenge:</strong></p><p>Need to model the whole spectrum: from repeated to stochastic texture.</p><p>One idea:</p><ol><li>Compute statistics of input texture</li><li>Generate a new texture that keeps those same statistics.</li></ol><p>But it is hard to model those probabilities distributions.</p><p>Another idea: ==Efros & Leung algorithm==</p><p>Given the neighbour, we want to calculate the probabiliy of appearing this pixel $p$ in the middle.</p><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009215711552.png alt=image-20231009215711552 style=zoom:33%><p>How to match pixels?</p><ul><li>Gaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels.</li></ul><p><code>\begin{align*} \text{SSD}(P, Q) = \sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\\ \text{where } w_{ij} = e^{ \frac{-(1-w/2)^2 - (j - h/2)^2}{2 \sigma^2} } \end{align*}</code></p><p>where $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.</p><ul><li><p>What order to fill in new pixels?</p><ul><li>&ldquo;Onion skin&rdquo; order: pixels with most neighbors are synthesized first.</li></ul></li></ul><p>How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.</p><h3 id=span-stylecolor3c66b5texture-synthesis-algorithmspan><span style=color:#3c66b5>Texture synthesis algorithm</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor3c66b5texture-synthesis-algorithmspan>#</a></h3><p>While image not filled:</p><ol><li>Get unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?)</li><li>For each pixel, get top <strong>N</strong> matches based on visible neighbors. This is where we use the Gaussian-weighted SSD.</li><li>Randomly select one of the matches and copy pixels from it.</li></ol><p>This algorithm can be used for hole filling, extrapolation, &mldr;</p><h3 id=hole-filling>Hole-Filling<a hidden class=anchor aria-hidden=true href=#hole-filling>#</a></h3><p>We can just use the texture synthesis algorithm.BUT, the order of filling matters.</p><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009221957013.png alt=image-20231009221957013 style=zoom:33%><p>Sometimes, we can add more weights for the continuous edges when peforming the onion filling. (Gradient sensitive). It makes the edges to be more intact.</p><h3 id=we-want-it-to-be-faster>We want it to be faster<a hidden class=anchor aria-hidden=true href=#we-want-it-to-be-faster>#</a></h3><p>The Efros & Leung texture synthesis algorithm is simple and good, but too slow&mldr;</p><p>The next iteration is: <strong>Image quilting</strong> (Efros & Freeman 2001).</p><p>It depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.</p><img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915005500901.png?token=AMIENRZLD5ZXA5EANGARIVTFAPY7C" alt=image-20230915005500901 style=zoom:20%>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915011020137.png?token=AMIENR7XTCJAIDHOVH7HO3TFAP2YQ" alt=image-20230915011020137 style=zoom:25%><p>We need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra&rsquo;s algorithm, we can easy calculate what we want.</p><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230917162048471.png alt=image-20230917162048471 style=zoom:25%><h3 id=texture-transfer>Texture Transfer<a hidden class=anchor aria-hidden=true href=#texture-transfer>#</a></h3><p>Very similar to texture synthesis, but in a more restricted condition:
$$
\text{cost} = \alpha * \text{SSD}<em>{overlap} + (1-\alpha)* \text{SSD}</em>{transfer}
$$</p><h3 id=image-analogies>Image Analogies<a hidden class=anchor aria-hidden=true href=#image-analogies>#</a></h3><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230917175927224.png alt=image-20230917175927224 style=zoom:25%><hr><h1 id=intelligent--scissors-and-graph-cuts>Intelligent Scissors and Graph Cuts<a hidden class=anchor aria-hidden=true href=#intelligent--scissors-and-graph-cuts>#</a></h1><blockquote><p>We want to find seams and boundaries. Then, CUT!</p></blockquote><p>Fundamental Concepts: The image as a <strong>Graph</strong></p><ul><li>Intelligent Scissers: Good boundary = short path</li><li>Graph cuts: Good region has low cutting cost.</li></ul><p>The goal of<strong>Semi-automated segmentation:</strong> User provides imprecise and incomplete specification of region — your algorithm has to read his/her mind.</p><p>A <strong>good region</strong>:</p><ul><li>Contains small range of color/ texture.</li><li>Looks different than background</li><li>Compact</li></ul><p>A <strong>good boundary</strong>:</p><ul><li>High gradient along boundary</li><li>Gradient in right direction</li><li>Smooth</li></ul><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009223822191.png alt=image-20231009223822191 style=zoom:33%>
<img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009223946992.png alt=image-20231009223946992 style=zoom:33%><figcaption>CS445 Hoiem. Good Region and good boundary.</figcaption></figure></center><h3 id=intelligent-scissors>Intelligent Scissors<a hidden class=anchor aria-hidden=true href=#intelligent-scissors>#</a></h3><p>Consider these image as a graph. Think of pixels as <strong>nodes</strong>, and think of cost of the path between two pixels as <strong>weighted edges</strong>.</p><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009224521565.png alt="intelligent scissors" style=zoom:33%><figcaption>Intelligent Scissors. Mortenson and Barrett (SIGGRAPH 1995)</figcaption></figure></center>Using this model, a **good boundary** of an image has a short path through the graph.<p>Formulation: find good boundary between seed points.</p><p>Challenges:</p><ul><li>Minimize interaction time</li><li>Define what makes a good boundary</li><li>Efficienctly find it</li></ul><p>Luckily, these can be achieved by using Dijkstra&rsquo;s algorithm with a properly defined graph.</p><h4 id=intelligent-scissors-method>Intelligent Scissors method<a hidden class=anchor aria-hidden=true href=#intelligent-scissors-method>#</a></h4><ol><li><p>Define boundary cost between neighboring pixels</p><ul><li><p>Lower if edge is present</p></li><li><p>Lower is gradient is strong</p></li><li><p>Lower if gradient is in direction of boundary</p></li></ul></li><li><p>User specifies a starting point (seed)</p><ul><li>A little snapping to the edges makes pixel-perfect operation not neccessary.</li></ul></li><li><p>Compute lowest cost from seed to each other pixel</p><ul><li>Dijkstra&rsquo;s shortest path algorithm</li></ul></li><li><p>Get path from seed to cursor, choose new seed, repeat</p></li></ol><p>Using this boundary cost, the path tends to follow the edges of objects. It makes the algorithm works. Dijkstra&rsquo;s algorithm makes it fast.</p><h3 id=graph-cuts>Graph Cuts<a hidden class=anchor aria-hidden=true href=#graph-cuts>#</a></h3><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231014171438104.png style=width:25%>
<img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231014172231451.png style=width:25%><figcaption>CS445 Hoiem</figcaption></figure></center><p>Look at the energe function, $y$ in the function represents the label of pixels (whether they belong to label 0 or 1). And, there are two kinds of cost.</p><ul><li>The first one is the unary cost, it measures whether the pixel is more similar to label 0 or 1.</li><li>The second one is a pair wise cose, which allows groups of pixels to be assigned to the same label.</li></ul><p>The goal of the graph cut algorithm is to find a cut through the graph to seperate the foreground and the background.</p><h4 id=the-graph-cut-segmentation-algorithm>The Graph Cut Segmentation algorithm:<a hidden class=anchor aria-hidden=true href=#the-graph-cut-segmentation-algorithm>#</a></h4><ol><li>Define graph<ul><li>usually 4-connected or 8-connected</li></ul></li><li>Set weights to foreground/background<ul><li>Color histogram or mixture of Gaussians for background and foreground. More foreground tends to be negative.</li></ul></li></ol><p>$$
\textit { unary_ potential }(x)=-\log \left(\frac{P\left(c(x) ; \theta_{\text {foreground }}\right)}{P\left(c(x) ; \theta_{\text {background }}\right)}\right)
$$
3. Set weights for edges between pixels</p><p>$$
\textit { edge_ potential }(x, y)=k_1+k_2
\exp\left{
\frac{-|c(x)-c(y)|^2}{2 \sigma^2}
\right}
$$</p><ol start=4><li>Apply min-cut/max-flow algorithm foreground, background models</li><li>Return to 2, using current labels to compute foreground, background models.</li></ol><h4 id=limitations-of-graph-cut>Limitations of Graph Cut<a hidden class=anchor aria-hidden=true href=#limitations-of-graph-cut>#</a></h4><ul><li>Requires associative graphs<ul><li>Connected notes should prefer to have the same label</li></ul></li><li>Is optimal only for binary problems</li></ul><h3 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h3><p>CS445 Derek Hoiem: <a href=https://courses.engr.illinois.edu/cs445/fa2023/>https://courses.engr.illinois.edu/cs445/fa2023/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ofuro.me/tags/computational-photography/>Computational Photography</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>