<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>445_Synthesizing and Cutting | Sam&#39;s Notes</title>
<meta name="keywords" content="Computational Photography">
<meta name="description" content="Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?
Definition Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.">
<meta name="author" content="">
<link rel="canonical" href="https://ohuro.me/posts/445_synthesizing-cutting/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ohuro.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ohuro.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ohuro.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ohuro.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://ohuro.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

 

 <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
 <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 
 
 <script>
   MathJax = {
     tex: {
       inlineMath: [['$', '$'], ['\\(', '\\)']],
       displayMath: [['$$','$$'], ['\\[', '\\]']],
       processEscapes: true,
       processEnvironments: true
     },
     options: {
       skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
     }
   };
 
   window.addEventListener('load', (event) => {
       document.querySelectorAll("mjx-container").forEach(function(x){
         x.parentElement.classList += 'has-jax'})
     });
 
 </script>


<script src="//yihui.org/js/math-code.js" defer></script>

<meta property="og:title" content="445_Synthesizing and Cutting" />
<meta property="og:description" content="Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?
Definition Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohuro.me/posts/445_synthesizing-cutting/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-30T10:33:26-05:00" />
<meta property="article:modified_time" content="2023-10-30T10:33:26-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="445_Synthesizing and Cutting"/>
<meta name="twitter:description" content="Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?
Definition Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ohuro.me/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "445_Synthesizing and Cutting",
      "item": "https://ohuro.me/posts/445_synthesizing-cutting/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "445_Synthesizing and Cutting",
  "name": "445_Synthesizing and Cutting",
  "description": "Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?\nDefinition Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.",
  "keywords": [
    "Computational Photography"
  ],
  "articleBody": "Texture Synthesis and Hole-Filling How do we cut something out of an image, and fill the hole naturally?\nDefinition Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.\nAnother idea: ==Efros \u0026 Leung algorithm==\nGiven the neighbour, we want to calculate the probabiliy of appearing this pixel $p$ in the middle.\nHow to match pixels?\nGaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels. \\begin{align*} \\text{SSD}(P, Q) = \\sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\\\\ \\text{where } w_{ij} = e^{ \\frac{-(1-w/2)^2 - (j - h/2)^2}{2 \\sigma^2} } \\end{align*}\nwhere $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.\nWhat order to fill in new pixels?\n“Onion skin” order: pixels with most neighbors are synthesized first. How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.\nTexture synthesis algorithm While image not filled:\nGet unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?) For each pixel, get top N matches based on visible neighbors. This is where we use the Gaussian-weighted SSD. Randomly select one of the matches and copy pixels from it. This algorithm can be used for hole filling, extrapolation, …\nHole-Filling We can just use the texture synthesis algorithm.BUT, the order of filling matters.\nSometimes, we can add more weights for the continuous edges when peforming the onion filling. (Gradient sensitive). It makes the edges to be more intact.\nWe want it to be faster The Efros \u0026 Leung texture synthesis algorithm is simple and good, but too slow…\nThe next iteration is: Image quilting (Efros \u0026 Freeman 2001).\nIt depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.\nWe need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra’s algorithm, we can easy calculate what we want.\nTexture Transfer Very similar to texture synthesis, but in a more restricted condition: $$ \\text{cost} = \\alpha * \\text{SSD}{overlap} + (1-\\alpha)* \\text{SSD}{transfer} $$\nImage Analogies Intelligent Scissors and Graph Cuts We want to find seams and boundaries. Then, CUT!\nFundamental Concepts: The image as a Graph\nIntelligent Scissers: Good boundary = short path Graph cuts: Good region has low cutting cost. The goal ofSemi-automated segmentation: User provides imprecise and incomplete specification of region — your algorithm has to read his/her mind.\nA good region:\nContains small range of color/ texture. Looks different than background Compact A good boundary:\nHigh gradient along boundary Gradient in right direction Smooth CS445 Hoiem. Good Region and good boundary. Intelligent Scissors Consider these image as a graph. Think of pixels as nodes, and think of cost of the path between two pixels as weighted edges.\nIntelligent Scissors. Mortenson and Barrett (SIGGRAPH 1995) Using this model, a **good boundary** of an image has a short path through the graph. Formulation: find good boundary between seed points.\nChallenges:\nMinimize interaction time Define what makes a good boundary Efficienctly find it Luckily, these can be achieved by using Dijkstra’s algorithm with a properly defined graph.\nIntelligent Scissors method Define boundary cost between neighboring pixels\nLower if edge is present\nLower is gradient is strong\nLower if gradient is in direction of boundary\nUser specifies a starting point (seed)\nA little snapping to the edges makes pixel-perfect operation not neccessary. Compute lowest cost from seed to each other pixel\nDijkstra’s shortest path algorithm Get path from seed to cursor, choose new seed, repeat\nUsing this boundary cost, the path tends to follow the edges of objects. It makes the algorithm works. Dijkstra’s algorithm makes it fast.\nGraph Cuts CS445 Hoiem Look at the energe function, $y$ in the function represents the label of pixels (whether they belong to label 0 or 1). And, there are two kinds of cost.\nThe first one is the unary cost, it measures whether the pixel is more similar to label 0 or 1. The second one is a pair wise cose, which allows groups of pixels to be assigned to the same label. The goal of the graph cut algorithm is to find a cut through the graph to seperate the foreground and the background.\nThe Graph Cut Segmentation algorithm: Define graph usually 4-connected or 8-connected Set weights to foreground/background Color histogram or mixture of Gaussians for background and foreground. More foreground tends to be negative. $$ \\textit { unary_ potential }(x)=-\\log \\left(\\frac{P\\left(c(x) ; \\theta_{\\text {foreground }}\\right)}{P\\left(c(x) ; \\theta_{\\text {background }}\\right)}\\right) $$ 3. Set weights for edges between pixels\n$$ \\textit { edge_ potential }(x, y)=k_1+k_2 \\exp\\left{ \\frac{-|c(x)-c(y)|^2}{2 \\sigma^2} \\right} $$\nApply min-cut/max-flow algorithm foreground, background models Return to 2, using current labels to compute foreground, background models. Limitations of Graph Cut Requires associative graphs Connected notes should prefer to have the same label Is optimal only for binary problems Reference CS445 Derek Hoiem: https://courses.engr.illinois.edu/cs445/fa2023/\n",
  "wordCount" : "894",
  "inLanguage": "en",
  "datePublished": "2023-10-30T10:33:26-05:00",
  "dateModified": "2023-10-30T10:33:26-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ohuro.me/posts/445_synthesizing-cutting/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sam's Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ohuro.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ohuro.me/" accesskey="h" title="Sam&#39;s Notes (Alt + H)">Sam&#39;s Notes</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ohuro.me/about" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
            <li>
                <a href="https://ohuro.me/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://ohuro.me/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://ohuro.me/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      445_Synthesizing and Cutting
    </h1>
    <div class="post-meta"><span title='2023-10-30 10:33:26 -0500 -0500'>October 30, 2023</span>

</div>
  </header> 
  <div class="post-content"><h2 id="texture-synthesis-and-hole-filling">Texture Synthesis and Hole-Filling<a hidden class="anchor" aria-hidden="true" href="#texture-synthesis-and-hole-filling">#</a></h2>
<blockquote>
<p>How do we cut something out of an image, and fill the hole naturally?</p>
</blockquote>
<p><span style="color:#28a745">Definition</span> Texture depicts spacially repeating patterns.</p>
<h3 id="texture-synthesis">Texture Synthesis<a hidden class="anchor" aria-hidden="true" href="#texture-synthesis">#</a></h3>
<p>Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.</p>
<p><strong>The challenge:</strong></p>
<p>Need to model the whole spectrum: from repeated to stochastic texture.</p>
<p>One idea:</p>
<ol>
<li>Compute statistics of input texture</li>
<li>Generate a new texture that keeps those same statistics.</li>
</ol>
<p>But it is hard to model those probabilities distributions.</p>
<p>Another idea: ==Efros &amp; Leung algorithm==</p>
<p>Given the neighbour, we want to calculate the probabiliy of appearing this pixel $p$ in the middle.</p>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009215711552.png" alt="image-20231009215711552" style="zoom:33%;" />
<p>How to match pixels?</p>
<ul>
<li>Gaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels.</li>
</ul>
<p><code>\begin{align*} \text{SSD}(P, Q) = \sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\\ \text{where } w_{ij} = e^{ \frac{-(1-w/2)^2 - (j - h/2)^2}{2 \sigma^2} } \end{align*}</code></p>
<p>where $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.</p>
<ul>
<li>
<p>What order to fill in new pixels?</p>
<ul>
<li>&ldquo;Onion skin&rdquo; order: pixels with most neighbors are synthesized first.</li>
</ul>
</li>
</ul>
<p>How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.</p>
<h3 id="span-stylecolor3c66b5texture-synthesis-algorithmspan"><span style="color:#3c66b5">Texture synthesis algorithm</span><a hidden class="anchor" aria-hidden="true" href="#span-stylecolor3c66b5texture-synthesis-algorithmspan">#</a></h3>
<p>While image not filled:</p>
<ol>
<li>Get unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?)</li>
<li>For each pixel, get top <strong>N</strong> matches based on visible neighbors. This is where we use the Gaussian-weighted SSD.</li>
<li>Randomly select one of the matches and copy pixels from it.</li>
</ol>
<p>This algorithm can be used for hole filling, extrapolation, &hellip;</p>
<h3 id="hole-filling">Hole-Filling<a hidden class="anchor" aria-hidden="true" href="#hole-filling">#</a></h3>
<p>We can just use the texture synthesis algorithm.BUT, the order of filling matters.</p>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009221957013.png" alt="image-20231009221957013" style="zoom:33%;" />
<p>Sometimes, we can add more weights for the continuous edges when peforming the onion filling. (Gradient sensitive). It makes the edges to be more intact.</p>
<h3 id="we-want-it-to-be-faster">We want it to be faster<a hidden class="anchor" aria-hidden="true" href="#we-want-it-to-be-faster">#</a></h3>
<p>The Efros &amp; Leung texture synthesis algorithm is simple and good, but too slow&hellip;</p>
<p>The next iteration is: <strong>Image quilting</strong> (Efros &amp; Freeman 2001).</p>
<p>It depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.</p>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915005500901.png?token=AMIENRZLD5ZXA5EANGARIVTFAPY7C" alt="image-20230915005500901" style="zoom:20%;" />
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915011020137.png?token=AMIENR7XTCJAIDHOVH7HO3TFAP2YQ" alt="image-20230915011020137" style="zoom:25%;" />
<p>We need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra&rsquo;s algorithm, we can easy calculate what we want.</p>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230917162048471.png" alt="image-20230917162048471" style="zoom:25%;" />
<h3 id="texture-transfer">Texture Transfer<a hidden class="anchor" aria-hidden="true" href="#texture-transfer">#</a></h3>
<p>Very similar to texture synthesis, but in a more restricted condition:
$$
\text{cost} = \alpha * \text{SSD}<em>{overlap} + (1-\alpha)* \text{SSD}</em>{transfer}
$$</p>
<h3 id="image-analogies">Image Analogies<a hidden class="anchor" aria-hidden="true" href="#image-analogies">#</a></h3>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230917175927224.png" alt="image-20230917175927224" style="zoom: 25%;" />
<hr>
<h1 id="intelligent--scissors-and-graph-cuts">Intelligent  Scissors and Graph Cuts<a hidden class="anchor" aria-hidden="true" href="#intelligent--scissors-and-graph-cuts">#</a></h1>
<blockquote>
<p>We want to find seams and boundaries. Then, CUT!</p>
</blockquote>
<p>Fundamental Concepts: The image as a <strong>Graph</strong></p>
<ul>
<li>Intelligent Scissers: Good boundary = short path</li>
<li>Graph cuts: Good region has low cutting cost.</li>
</ul>
<p>The goal of<strong>Semi-automated segmentation:</strong> User provides imprecise and incomplete specification of region — your algorithm has to read his/her mind.</p>
<p>A <strong>good region</strong>:</p>
<ul>
<li>Contains small range of color/ texture.</li>
<li>Looks different than background</li>
<li>Compact</li>
</ul>
<p>A <strong>good boundary</strong>:</p>
<ul>
<li>High gradient along boundary</li>
<li>Gradient in right direction</li>
<li>Smooth</li>
</ul>
<center>
  <figure>
    <img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009223822191.png" alt="image-20231009223822191" style="zoom:33%;" />
    <img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009223946992.png" alt="image-20231009223946992" style="zoom:33%;" />
    <figcaption> CS445 Hoiem. Good Region and good boundary. </figcaption>
  </figure>
</center>
<h3 id="intelligent-scissors">Intelligent Scissors<a hidden class="anchor" aria-hidden="true" href="#intelligent-scissors">#</a></h3>
<p>Consider these image as a graph. Think of pixels as <strong>nodes</strong>, and think of cost of the path between two pixels as <strong>weighted edges</strong>.</p>
<center>
  <figure>
    <img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231009224521565.png" alt="intelligent scissors" style="zoom:33%;" />
    <figcaption> Intelligent Scissors. Mortenson and Barrett (SIGGRAPH 1995) </figcaption>
  </figure>
</center>
Using this model, a **good boundary** of an image has a short path through the graph. 
<p>Formulation: find good boundary between seed points.</p>
<p>Challenges:</p>
<ul>
<li>Minimize interaction time</li>
<li>Define what makes a good boundary</li>
<li>Efficienctly find it</li>
</ul>
<p>Luckily, these can be achieved by using Dijkstra&rsquo;s algorithm with a properly defined graph.</p>
<h4 id="intelligent-scissors-method">Intelligent Scissors method<a hidden class="anchor" aria-hidden="true" href="#intelligent-scissors-method">#</a></h4>
<ol>
<li>
<p>Define boundary cost between neighboring pixels</p>
<ul>
<li>
<p>Lower if edge is present</p>
</li>
<li>
<p>Lower is gradient is strong</p>
</li>
<li>
<p>Lower if gradient is in direction of boundary</p>
</li>
</ul>
</li>
<li>
<p>User specifies a starting point (seed)</p>
<ul>
<li>A little snapping to the edges makes pixel-perfect operation not neccessary.</li>
</ul>
</li>
<li>
<p>Compute lowest cost from seed to each other pixel</p>
<ul>
<li>Dijkstra&rsquo;s shortest path algorithm</li>
</ul>
</li>
<li>
<p>Get path from seed to cursor, choose new seed, repeat</p>
</li>
</ol>
<p>Using this boundary cost, the path tends to follow the edges of objects. It makes the algorithm works. Dijkstra&rsquo;s algorithm makes it fast.</p>
<h3 id="graph-cuts">Graph Cuts<a hidden class="anchor" aria-hidden="true" href="#graph-cuts">#</a></h3>
<center>
  <figure>
    <img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231014171438104.png" style="width:25%;" />
    <img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20231014172231451.png" style="width:25%;" />
    <figcaption> CS445 Hoiem </figcaption>
  </figure>
</center>
<p>Look at the energe function, $y$ in the function represents the label of pixels (whether they belong to label 0 or 1). And, there are two kinds of cost.</p>
<ul>
<li>The first one is the unary cost, it measures whether the pixel is more similar to label 0 or 1.</li>
<li>The second one is a pair wise cose, which allows groups of pixels to be assigned to the same label.</li>
</ul>
<p>The goal of the graph cut algorithm is to find a cut through the graph to seperate the foreground and the background.</p>
<h4 id="the-graph-cut-segmentation-algorithm">The Graph Cut Segmentation algorithm:<a hidden class="anchor" aria-hidden="true" href="#the-graph-cut-segmentation-algorithm">#</a></h4>
<ol>
<li>Define graph
<ul>
<li>usually 4-connected or 8-connected</li>
</ul>
</li>
<li>Set weights to foreground/background
<ul>
<li>Color histogram or mixture of Gaussians for background and foreground. More foreground tends to be negative.</li>
</ul>
</li>
</ol>
<p>$$
\textit { unary_ potential }(x)=-\log \left(\frac{P\left(c(x) ; \theta_{\text {foreground }}\right)}{P\left(c(x) ; \theta_{\text {background }}\right)}\right)
$$
3. Set weights for edges between pixels</p>
<p>$$
\textit { edge_ potential }(x, y)=k_1+k_2
\exp\left{
\frac{-|c(x)-c(y)|^2}{2 \sigma^2}
\right}
$$</p>
<ol start="4">
<li>Apply min-cut/max-flow algorithm foreground, background models</li>
<li>Return to 2, using current labels to compute foreground, background models.</li>
</ol>
<h4 id="limitations-of-graph-cut">Limitations of Graph Cut<a hidden class="anchor" aria-hidden="true" href="#limitations-of-graph-cut">#</a></h4>
<ul>
<li>Requires associative graphs
<ul>
<li>Connected notes should prefer to have the same label</li>
</ul>
</li>
<li>Is optimal only for binary problems</li>
</ul>
<h3 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h3>
<p>CS445 Derek Hoiem: <a href="https://courses.engr.illinois.edu/cs445/fa2023/">https://courses.engr.illinois.edu/cs445/fa2023/</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ohuro.me/tags/computational-photography/">Computational Photography</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ohuro.me/">Sam&#39;s Notes</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
