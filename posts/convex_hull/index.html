<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Convex Hull in 2D | Yue's Notes</title>
<meta name=keywords content><meta name=description content="Definition Problem: Given $n$ points $P = \set{p_1, \ldots, p_n} \subset \mathbb{R}^2$, compute $\text{CH}(P) = $ smallest convex set contining $P$.
Input: a list of points all the points in $P$.
Output: a list of points in $P$ that belongs to this convex set in CCW, starting from the left most point.
Applications


Given a huge point cloud, convex hull helps find the &ldquo;shape&rdquo;.


Bounding volume. Makes ray shooting tasks faster."><meta name=author content><link rel=canonical href=https://ofuro.me/posts/convex_hull/><link crossorigin=anonymous href=/assets/css/stylesheet.6a49f6cf4a2bdda56a77391d7f5624ae4f617195770e1d3dfe5d3a759ad98336.css integrity="sha256-akn2z0or3aVqdzkdf1Ykrk9hcZV3Dh09/l06dZrZgzY=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/convex_hull/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/convex_hull/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="Convex Hull in 2D"><meta property="og:description" content="Definition Problem: Given $n$ points $P = \set{p_1, \ldots, p_n} \subset \mathbb{R}^2$, compute $\text{CH}(P) = $ smallest convex set contining $P$.
Input: a list of points all the points in $P$.
Output: a list of points in $P$ that belongs to this convex set in CCW, starting from the left most point.
Applications Given a huge point cloud, convex hull helps find the “shape”.
Bounding volume. Makes ray shooting tasks faster."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-29T17:02:49-05:00"><meta property="article:modified_time" content="2024-08-29T17:02:49-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Convex Hull in 2D"><meta name=twitter:description content="Definition Problem: Given $n$ points $P = \set{p_1, \ldots, p_n} \subset \mathbb{R}^2$, compute $\text{CH}(P) = $ smallest convex set contining $P$.
Input: a list of points all the points in $P$.
Output: a list of points in $P$ that belongs to this convex set in CCW, starting from the left most point.
Applications


Given a huge point cloud, convex hull helps find the &ldquo;shape&rdquo;.


Bounding volume. Makes ray shooting tasks faster."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"Convex Hull in 2D","item":"https://ofuro.me/posts/convex_hull/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Convex Hull in 2D","name":"Convex Hull in 2D","description":"Definition Problem: Given $n$ points $P = \\set{p_1, \\ldots, p_n} \\subset \\mathbb{R}^2$, compute $\\text{CH}(P) = $ smallest convex set contining $P$.\nInput: a list of points all the points in $P$.\nOutput: a list of points in $P$ that belongs to this convex set in CCW, starting from the left most point.\nApplications Given a huge point cloud, convex hull helps find the \u0026ldquo;shape\u0026rdquo;.\nBounding volume. Makes ray shooting tasks faster.\n","keywords":[],"articleBody":"Definition Problem: Given $n$ points $P = \\set{p_1, \\ldots, p_n} \\subset \\mathbb{R}^2$, compute $\\text{CH}(P) = $ smallest convex set contining $P$.\nInput: a list of points all the points in $P$.\nOutput: a list of points in $P$ that belongs to this convex set in CCW, starting from the left most point.\nApplications Given a huge point cloud, convex hull helps find the “shape”.\nBounding volume. Makes ray shooting tasks faster.\nExtreme points. It gives the most extreme points in any given direction.\nFarthest pair.\nLine separation. Natural, but not fastest.\nNow, let’s design some algorithms!\nMath properties $$ \\begin{align*} \\text{CH}(P) \u0026= \\bigcap_{\\text{convex } S \\supseteq P} S = \\bigcap_{\\text{half plane } h \\supseteq P} h \\\\ \u0026= \\set{ \\text{all convex combinations of } p_1, \\ldots, p_n}\\\\ \u0026= \\bigcup_{i, j, k} \\set{\\text{all convex triples $i, j, k$ (triangle)}} \\end{align*} $$ Convex combination: $$ \\sum_{i = 1}^{n} a_i p_i, \\; \\sum_{i = 1}^{n} a_i = 1, a_i \\geq 0. $$ Lemma $p_i$ is a vertex of $\\text{CH}(P)$ iff $\\exists$ line through $p_i$ such that $P$ lines on one side. (all other points on one side.)\nLemma $p_i p_j$ is an edge of $\\text{CH}(P)$ iff $P$ lines on one side of line $p_ip_j$.\nNote: suffice to compute upper hull(UH) to solve CH. UH is divided by $\\min x, \\max x$.\nBrute force for i = 1..n for j = 1..n flag = true for k = 1..n if p_k above p_i p_j then flag = false if flag then output p_i p_j $O(n^3)$ time.\nSome simple post processing is required to get the correct output.\nImplement issues: How to test $p_k$ is above $p_ip_j$? Degeneracies precision issues. 1. Test above Say $p_i$ is on the left of $p_j$ (smaller $x$).\nWe say $p_k$ below $p_ip_j$\niff $p_k$ is at the right of $\\vec{p_ip_j}$\niff $p_ip_jp_k$ is in CW order\niff $(x_k, y_k)$ below line with equation: $y - y_i = \\frac{y_j - y_i}{x_j - x_i}(x - x_i)$\niff $y_k - y_i \u003c \\frac{y_j - y_i}{x_j - x_i}(x_k - x_i)$ .\niff $(y_k - y_i)(x_j - x_i) \u003c (y_j - y_i)(x_k - x_i)$. This is a cross product!\niff $$ 2 \\cdot \\text{signed area of }\\Delta p_ip_jp_k \\begin{vmatrix} 1 \u0026 x_i \u0026 y_i\\\\ 1 \u0026 x_j \u0026 y_j\\\\ 1 \u0026 x_k \u0026 y_k\\\\ \\end{vmatrix} \u003c 0 $$ The good thing about the determinant test is that it extends to higher dimensions.\n2. Degeneracies What if some points are on the edge in real world data? We don’t consider it in theory :))) We consider the points in “general position”.\n3. Precision More messy stuff…\nAlgorithm 1: Jaruis March(1973) / “gift wrapping” Looks like a selection sort.\nIdea: go from one UH vertex to next.\nq_1 = the leftmost point. \u003c--- O(n) time. for i = 1 to n do { if (q_i = rightmost point) then { return (q_1, ..., q_i) } q_{i+1} = any init point to the right. for k = 1 to n do { if (p_k right of q_i) AND (p_k above q_iq_{i+1}) then { q_{i+1} = p_k } } } $O(n^2)$ running time.\nAlgorithm 2: Graham Scan (1972) Looks like an insertion sort.\nIdea:\nadd points one at a time and maintain the UH. (Incremental approach). go from left to right. (Sweeping technique) We add the highest point on the scanning line, then update the hull by relaxing. Keep deleting suffix untill a CW appears. I will skip the pseudocode.\nAnalysis: Naively $O(n^2)$. But, what if we bound the number of iterations for relaxation? Observation, the total relaxation time is bounded by $O(n)$. $$ O(n + \\# \\text{decrement}) \\leq O(n + \\# \\text{increment}) = O(n) $$ But we do have a sorting in $O(n \\log n)$.\n","wordCount":"618","inLanguage":"en","datePublished":"2024-08-29T17:02:49-05:00","dateModified":"2024-08-29T17:02:49-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/convex_hull/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Convex Hull in 2D</h1><div class=post-meta><span title='2024-08-29 17:02:49 -0500 -0500'>August 29, 2024</span></div></header><div class=post-content><p><span style=color:#28a745>Definition</span> Problem: Given $n$ points $P = \set{p_1, \ldots, p_n} \subset \mathbb{R}^2$, compute $\text{CH}(P) = $ smallest convex set contining $P$.</p><p>Input: a list of points all the points in $P$.</p><p>Output: a list of points in $P$ that belongs to this convex set in CCW, starting from the left most point.</p><h4 id=applications>Applications<a hidden class=anchor aria-hidden=true href=#applications>#</a></h4><ul><li><p>Given a huge point cloud, convex hull helps find the &ldquo;shape&rdquo;.</p></li><li><p>Bounding volume. Makes ray shooting tasks faster.</p></li><li><p>Extreme points. It gives the most extreme points in any given direction.</p></li><li><p>Farthest pair.</p></li><li><p>Line separation. Natural, but not fastest.</p></li></ul><p>Now, let&rsquo;s design some algorithms!</p><h3 id=math-properties>Math properties<a hidden class=anchor aria-hidden=true href=#math-properties>#</a></h3><div>$$
\begin{align*}
\text{CH}(P) &= \bigcap_{\text{convex } S \supseteq P} S =
\bigcap_{\text{half plane } h \supseteq P} h \\
&= \set{ \text{all convex combinations of } p_1, \ldots, p_n}\\
&= \bigcup_{i, j, k} \set{\text{all convex triples $i, j, k$ (triangle)}}
\end{align*}
$$</div><p>Convex combination:<div>$$
\sum_{i = 1}^{n} a_i p_i, \; \sum_{i = 1}^{n} a_i = 1, a_i \geq 0.
$$</div></p><p><span style=color:#599eff>Lemma</span> $p_i$ is a vertex of $\text{CH}(P)$ iff $\exists$ line through $p_i$ such that $P$ lines on one side. (all other points on one side.)</p><p><span style=color:#599eff>Lemma</span> $p_i p_j$ is an edge of $\text{CH}(P)$ iff $P$ lines on one side of line $p_ip_j$.</p><p>Note: suffice to compute upper hull(UH) to solve CH. UH is divided by $\min x, \max x$.</p><hr><h3 id=span-stylecolor3c66b5brute-forcespan><span style=color:#3c66b5>Brute force</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor3c66b5brute-forcespan>#</a></h3><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>for i = 1..n
	for j = 1..n
		flag = true
		for k = 1..n
			if p_k above p_i p_j then flag = false
		if flag then output p_i p_j
</code></pre><p>$O(n^3)$ time.</p><p>Some simple post processing is required to get the correct output.</p><h4 id=implement-issues>Implement issues:<a hidden class=anchor aria-hidden=true href=#implement-issues>#</a></h4><ol><li>How to test $p_k$ is above $p_ip_j$?</li><li>Degeneracies</li><li>precision issues.</li></ol><h4 id=1-test-above>1. Test above<a hidden class=anchor aria-hidden=true href=#1-test-above>#</a></h4><p>Say $p_i$ is on the left of $p_j$ (smaller $x$).</p><p>We say $p_k$ below $p_ip_j$</p><ul><li><p>iff $p_k$ is at the right of $\vec{p_ip_j}$</p></li><li><p>iff $p_ip_jp_k$ is in CW order</p></li><li><p>iff $(x_k, y_k)$ below line with equation: $y - y_i = \frac{y_j - y_i}{x_j - x_i}(x - x_i)$</p></li><li><p>iff $y_k - y_i &lt; \frac{y_j - y_i}{x_j - x_i}(x_k - x_i)$ .</p></li><li><p>iff $(y_k - y_i)(x_j - x_i) &lt; (y_j - y_i)(x_k - x_i)$. This is a cross product!</p></li><li><p>iff<div>$$
2 \cdot \text{signed area of }\Delta p_ip_jp_k
\begin{vmatrix}
1 & x_i & y_i\\
1 & x_j & y_j\\
1 & x_k & y_k\\
\end{vmatrix}
 < 0
$$
</div></p></li></ul><p>The good thing about the determinant test is that it extends to higher dimensions.</p><h4 id=2-degeneracies>2. Degeneracies<a hidden class=anchor aria-hidden=true href=#2-degeneracies>#</a></h4><p>What if some points are on the edge in real world data? We don&rsquo;t consider it in theory :))) We consider the points in &ldquo;general position&rdquo;.</p><h4 id=3-precision>3. Precision<a hidden class=anchor aria-hidden=true href=#3-precision>#</a></h4><p>More messy stuff&mldr;</p><hr><h3 id=algorithm-1-jaruis-march1973--gift-wrapping>Algorithm 1: Jaruis March(1973) / &ldquo;gift wrapping&rdquo;<a hidden class=anchor aria-hidden=true href=#algorithm-1-jaruis-march1973--gift-wrapping>#</a></h3><blockquote><p>Looks like a selection sort.</p></blockquote><p>Idea: go from one UH vertex to next.</p><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>q_1 = the leftmost point. 		&lt;--- O(n) time.
for i = 1 to n do {
	if (q_i = rightmost point) then {
		return (q_1, ..., q_i)
	}
	q_{i+1} = any init point to the right.
	for k = 1 to n do {
		if (p_k right of q_i) AND (p_k above q_iq_{i+1}) then {
			q_{i+1} = p_k
		}
	}
}
</code></pre><p>$O(n^2)$ running time.</p><h3 id=algorithm-2-graham-scan-1972>Algorithm 2: Graham Scan (1972)<a hidden class=anchor aria-hidden=true href=#algorithm-2-graham-scan-1972>#</a></h3><blockquote><p>Looks like an insertion sort.</p></blockquote><p>Idea:</p><ul><li>add points one at a time and maintain the UH. (Incremental approach).</li><li>go from left to right. (Sweeping technique)</li><li>We add the highest point on the scanning line, then update the hull by relaxing. Keep deleting suffix untill a CW appears.</li></ul><p>I will skip the pseudocode.</p><h4 id=analysis>Analysis:<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h4><p>Naively $O(n^2)$. But, what if we bound the number of iterations for relaxation? Observation, the total relaxation time is bounded by $O(n)$.<div>$$
O(n + \# \text{decrement}) \leq O(n + \# \text{increment}) = O(n)
$$</div>But we do have a sorting in $O(n \log n)$.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>