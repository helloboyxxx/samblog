<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>445_texture | Sam&#39;s Notes</title>
<meta name="keywords" content="Computational Photography">
<meta name="description" content="Texture Synthesis &amp; Hole Filling Texture Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.
Another idea: ==Efros &amp; Leung algorithm==">
<meta name="author" content="">
<link rel="canonical" href="https://ohuro.me/posts/445_texture/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ohuro.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ohuro.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ohuro.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ohuro.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://ohuro.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

 

 <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
 <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 
 
 <script>
   MathJax = {
     tex: {
       inlineMath: [['$', '$'], ['\\(', '\\)']],
       displayMath: [['$$','$$'], ['\\[', '\\]']],
       processEscapes: true,
       processEnvironments: true
     },
     options: {
       skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
     }
   };
 
   window.addEventListener('load', (event) => {
       document.querySelectorAll("mjx-container").forEach(function(x){
         x.parentElement.classList += 'has-jax'})
     });
 
 </script>


<script src="//yihui.org/js/math-code.js" defer></script>

<meta property="og:title" content="445_texture" />
<meta property="og:description" content="Texture Synthesis &amp; Hole Filling Texture Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.
Another idea: ==Efros &amp; Leung algorithm==" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohuro.me/posts/445_texture/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-17T15:24:34-05:00" />
<meta property="article:modified_time" content="2023-09-17T15:24:34-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="445_texture"/>
<meta name="twitter:description" content="Texture Synthesis &amp; Hole Filling Texture Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.
Another idea: ==Efros &amp; Leung algorithm=="/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ohuro.me/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "445_texture",
      "item": "https://ohuro.me/posts/445_texture/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "445_texture",
  "name": "445_texture",
  "description": "Texture Synthesis \u0026amp; Hole Filling Texture Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.\nAnother idea: ==Efros \u0026amp; Leung algorithm==",
  "keywords": [
    "Computational Photography"
  ],
  "articleBody": "Texture Synthesis \u0026 Hole Filling Texture Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.\nAnother idea: ==Efros \u0026 Leung algorithm==\nHow to match patches?\nGaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels. $$ \\text{SSD}(P, Q) = \\sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\\ \\text{where } w_{ij} = e^{ \\frac{-(1-w/2)^2 - (j - h/2)^2}{2 \\sigma^2} } $$\nwhere $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.\nWhat order to fill in new pixels?\n“Onion skin” order: pixels with most neighbors are synthesized first. How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.\n$\\boldsymbol{\\textsf{Texture synthesis algorithm}}$ While image not filled:\nGet unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?) For each pixel, get top N matches based on visible neighbors. This is where we use the Gaussian-weighted SSD. Randomly select one of the matches and copy pixels from it. This algorithm can be used for hole filling, extrapolation, …\nHole Filling Sometimes, we can add more weights for the continuos edges when peforming the onion filling. (Gradient sensitive)\nThe Efros \u0026 Leung texture synthesis algorithm is simple and good, but too slow…\nThe next iteration is: Image quilting (Efros \u0026 Freeman 2001).\nIt depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.\nWe need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra’s algorithm, we can easy calculate what we want.\n",
  "wordCount" : "346",
  "inLanguage": "en",
  "datePublished": "2023-09-17T15:24:34-05:00",
  "dateModified": "2023-09-17T15:24:34-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ohuro.me/posts/445_texture/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sam's Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ohuro.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ohuro.me/" accesskey="h" title="Sam&#39;s Notes (Alt + H)">Sam&#39;s Notes</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ohuro.me/about" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
            <li>
                <a href="https://ohuro.me/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://ohuro.me/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://ohuro.me/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      445_texture
    </h1>
    <div class="post-meta"><span title='2023-09-17 15:24:34 -0500 -0500'>September 17, 2023</span>

</div>
  </header> 
  <div class="post-content"><h1 id="texture-synthesis--hole-filling">Texture Synthesis &amp; Hole Filling<a hidden class="anchor" aria-hidden="true" href="#texture-synthesis--hole-filling">#</a></h1>
<h4 id="texture">Texture<a hidden class="anchor" aria-hidden="true" href="#texture">#</a></h4>
<p>Texture depicts spacially repeating patterns.</p>
<h3 id="texture-synthesis">Texture Synthesis<a hidden class="anchor" aria-hidden="true" href="#texture-synthesis">#</a></h3>
<p>Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.</p>
<p><strong>The challenge:</strong></p>
<p>Need to model the whole spectrum: from repeated to stochastic texture.</p>
<p>One idea:</p>
<ol>
<li>Compute statistics of input texture</li>
<li>Generate a new texture that keeps those same statistics.</li>
</ol>
<p>But it is hard to model those probabilities distributions.</p>
<p>Another idea: ==Efros &amp; Leung algorithm==</p>
<p>How to match patches?</p>
<ul>
<li>Gaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels.</li>
</ul>
<p>$$
\text{SSD}(P, Q) = \sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\
\text{where } w_{ij} = e^{
\frac{-(1-w/2)^2 - (j - h/2)^2}{2 \sigma^2}
}
$$</p>
<p>where $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.</p>
<ul>
<li>
<p>What order to fill in new pixels?</p>
<ul>
<li>&ldquo;Onion skin&rdquo; order: pixels with most neighbors are synthesized first.</li>
</ul>
</li>
</ul>
<p>How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.</p>
<h3 id="span-stylecolor3c66b5boldsymboltextsftexture-synthesis-algorithmspan"><span style="color:#3c66b5">$\boldsymbol{\textsf{Texture synthesis algorithm}}$</span><a hidden class="anchor" aria-hidden="true" href="#span-stylecolor3c66b5boldsymboltextsftexture-synthesis-algorithmspan">#</a></h3>
<p>While image not filled:</p>
<ol>
<li>Get unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?)</li>
<li>For each pixel, get top <strong>N</strong> matches based on visible neighbors. This is where we use the Gaussian-weighted SSD.</li>
<li>Randomly select one of the matches and copy pixels from it.</li>
</ol>
<p>This algorithm can be used for hole filling, extrapolation, &hellip;</p>
<h3 id="hole-filling">Hole Filling<a hidden class="anchor" aria-hidden="true" href="#hole-filling">#</a></h3>
<p>Sometimes, we can add more weights for the continuos edges when peforming the onion filling. (Gradient sensitive)</p>
<p>The Efros &amp; Leung texture synthesis algorithm is simple and good, but too slow&hellip;</p>
<p>The next iteration is: <strong>Image quilting</strong> (Efros &amp; Freeman 2001).</p>
<p>It depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.</p>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915005500901.png?token=AMIENRZLD5ZXA5EANGARIVTFAPY7C" alt="image-20230915005500901" style="zoom:10%;" />
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915011020137.png?token=AMIENR7XTCJAIDHOVH7HO3TFAP2YQ" alt="image-20230915011020137" style="zoom:10%;" />
<p>We need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra&rsquo;s algorithm, we can easy calculate what we want.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ohuro.me/tags/computational-photography/">Computational Photography</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ohuro.me/">Sam&#39;s Notes</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
