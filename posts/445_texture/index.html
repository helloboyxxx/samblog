<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>445_texture | Yue's Notes</title>
<meta name=keywords content="Computational Photography"><meta name=description content="Texture Synthesis & Hole Filling
Texture
Texture depicts spacially repeating patterns.
Texture Synthesis
Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:

Compute statistics of input texture
Generate a new texture that keeps those same statistics.

But it is hard to model those probabilities distributions.
Another idea: ==Efros & Leung algorithm=="><meta name=author content><link rel=canonical href=https://ofuro.me/posts/445_texture/><link crossorigin=anonymous href=/assets/css/stylesheet.ca05f400083f47cd83432bdc19cb98f6190f54d8b144b22a8b1b89baa8dc285f.css integrity="sha256-ygX0AAg/R82DQyvcGcuY9hkPVNixRLIqixuJuqjcKF8=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/445_texture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/445_texture/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="445_texture"><meta property="og:description" content="Texture Synthesis & Hole Filling Texture Texture depicts spacially repeating patterns.
Texture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:
Compute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.
Another idea: ==Efros & Leung algorithm=="><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-17T15:24:34-05:00"><meta property="article:modified_time" content="2023-09-17T15:24:34-05:00"><meta property="article:tag" content="Computational Photography"><meta name=twitter:card content="summary"><meta name=twitter:title content="445_texture"><meta name=twitter:description content="Texture Synthesis & Hole Filling
Texture
Texture depicts spacially repeating patterns.
Texture Synthesis
Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.
The challenge:
Need to model the whole spectrum: from repeated to stochastic texture.
One idea:

Compute statistics of input texture
Generate a new texture that keeps those same statistics.

But it is hard to model those probabilities distributions.
Another idea: ==Efros & Leung algorithm=="><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"445_texture","item":"https://ofuro.me/posts/445_texture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"445_texture","name":"445_texture","description":"Texture Synthesis \u0026amp; Hole Filling Texture Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.\nAnother idea: ==Efros \u0026amp; Leung algorithm==\n","keywords":["Computational Photography"],"articleBody":"Texture Synthesis \u0026 Hole Filling Texture Texture depicts spacially repeating patterns.\nTexture Synthesis Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.\nThe challenge:\nNeed to model the whole spectrum: from repeated to stochastic texture.\nOne idea:\nCompute statistics of input texture Generate a new texture that keeps those same statistics. But it is hard to model those probabilities distributions.\nAnother idea: ==Efros \u0026 Leung algorithm==\nHow to match patches?\nGaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels. $$ \\text{SSD}(P, Q) = \\sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\\ \\text{where } w_{ij} = e^{ \\frac{-(1-w/2)^2 - (j - h/2)^2}{2 \\sigma^2} } $$\nwhere $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.\nWhat order to fill in new pixels?\n“Onion skin” order: pixels with most neighbors are synthesized first. How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.\n$\\boldsymbol{\\textsf{Texture synthesis algorithm}}$ While image not filled:\nGet unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?) For each pixel, get top N matches based on visible neighbors. This is where we use the Gaussian-weighted SSD. Randomly select one of the matches and copy pixels from it. This algorithm can be used for hole filling, extrapolation, …\nHole Filling Sometimes, we can add more weights for the continuos edges when peforming the onion filling. (Gradient sensitive)\nThe Efros \u0026 Leung texture synthesis algorithm is simple and good, but too slow…\nThe next iteration is: Image quilting (Efros \u0026 Freeman 2001).\nIt depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.\nWe need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra’s algorithm, we can easy calculate what we want.\n","wordCount":"346","inLanguage":"en","datePublished":"2023-09-17T15:24:34-05:00","dateModified":"2023-09-17T15:24:34-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/445_texture/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">445_texture</h1><div class=post-meta><span title='2023-09-17 15:24:34 -0500 -0500'>September 17, 2023</span></div></header><div class=post-content><h1 id=texture-synthesis--hole-filling>Texture Synthesis & Hole Filling<a hidden class=anchor aria-hidden=true href=#texture-synthesis--hole-filling>#</a></h1><h4 id=texture>Texture<a hidden class=anchor aria-hidden=true href=#texture>#</a></h4><p>Texture depicts spacially repeating patterns.</p><h3 id=texture-synthesis>Texture Synthesis<a hidden class=anchor aria-hidden=true href=#texture-synthesis>#</a></h3><p>Create new samples of a given texture. Many applications: virtual environments, hole-filling, texturing surfaces.</p><p><strong>The challenge:</strong></p><p>Need to model the whole spectrum: from repeated to stochastic texture.</p><p>One idea:</p><ol><li>Compute statistics of input texture</li><li>Generate a new texture that keeps those same statistics.</li></ol><p>But it is hard to model those probabilities distributions.</p><p>Another idea: ==Efros & Leung algorithm==</p><p>How to match patches?</p><ul><li>Gaussian-weighted SSD (sum square difference) gives us more emphasis on nearby pixels.</li></ul><p>$$
\text{SSD}(P, Q) = \sum_{i, j}(p_{ij} - q_{ij})^2 w_{ij}\
\text{where } w_{ij} = e^{
\frac{-(1-w/2)^2 - (j - h/2)^2}{2 \sigma^2}
}
$$</p><p>where $P$, and $Q$, are two patches, $w$ and $h$ in the $w_{ij}$ is the width and height of the patch.</p><ul><li><p>What order to fill in new pixels?</p><ul><li>&ldquo;Onion skin&rdquo; order: pixels with most neighbors are synthesized first.</li></ul></li></ul><p>How big should the patches be? The size of neighborhood window decides how stochasticity of the texture. A smaller window size gives a more random output.</p><h3 id=span-stylecolor3c66b5boldsymboltextsftexture-synthesis-algorithmspan><span style=color:#3c66b5>$\boldsymbol{\textsf{Texture synthesis algorithm}}$</span><a hidden class=anchor aria-hidden=true href=#span-stylecolor3c66b5boldsymboltextsftexture-synthesis-algorithmspan>#</a></h3><p>While image not filled:</p><ol><li>Get unfilled pixels with filled neighbors, sorted by the numebr of filled neighbors. (priority queue?)</li><li>For each pixel, get top <strong>N</strong> matches based on visible neighbors. This is where we use the Gaussian-weighted SSD.</li><li>Randomly select one of the matches and copy pixels from it.</li></ol><p>This algorithm can be used for hole filling, extrapolation, &mldr;</p><h3 id=hole-filling>Hole Filling<a hidden class=anchor aria-hidden=true href=#hole-filling>#</a></h3><p>Sometimes, we can add more weights for the continuos edges when peforming the onion filling. (Gradient sensitive)</p><p>The Efros & Leung texture synthesis algorithm is simple and good, but too slow&mldr;</p><p>The next iteration is: <strong>Image quilting</strong> (Efros & Freeman 2001).</p><p>It depends on the observation that: neighbor pixels are highly correlated. Now, instead of filling pixel by pixel, we fill block by block.</p><img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915005500901.png?token=AMIENRZLD5ZXA5EANGARIVTFAPY7C" alt=image-20230915005500901 style=zoom:10%>
<img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20230915011020137.png?token=AMIENR7XTCJAIDHOVH7HO3TFAP2YQ" alt=image-20230915011020137 style=zoom:10%><p>We need to put the tiles together. To make them look seemless, we can use this minimal error boundary cut. We calculate the square difference of the overlapping part, and calcualte the boundary. Using this simplified Dijikstra&rsquo;s algorithm, we can easy calculate what we want.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ofuro.me/tags/computational-photography/>Computational Photography</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>