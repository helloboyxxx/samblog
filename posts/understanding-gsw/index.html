<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding GSW | Yue's Notes</title>
<meta name=keywords content="cryptography"><meta name=description content="The goal of this file is to help understand the GSW scheme and the implementation of GSWCiphertextin OnionPIR code. Let&rsquo;s start with my understanding of GSW scheme.
From TGSW to RGSW
RGSW is a ring variation of GSW scheme. I do not see any formal paper defining RGSW. However, I do find this particular paper helpful: Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds. This paper defines TLWE and TGSW."><meta name=author content><link rel=canonical href=https://ofuro.me/posts/understanding-gsw/><link crossorigin=anonymous href=/assets/css/stylesheet.3f9c3df41d49c1df83c4f93106bd40eae5ce265f122a1a1a99f034136f7c15f5.css integrity="sha256-P5w99B1Jwd+DxPkxBr1A6uXOJl8SKhoamfA0E298FfU=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/understanding-gsw/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/understanding-gsw/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="Understanding GSW"><meta property="og:description" content="The goal of this file is to help understand the GSW scheme and the implementation of GSWCiphertextin OnionPIR code. Let’s start with my understanding of GSW scheme.
From TGSW to RGSW RGSW is a ring variation of GSW scheme. I do not see any formal paper defining RGSW. However, I do find this particular paper helpful: Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds. This paper defines TLWE and TGSW."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-01T21:56:04-06:00"><meta property="article:modified_time" content="2024-10-01T21:56:04-06:00"><meta property="article:tag" content="Cryptography"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding GSW"><meta name=twitter:description content="The goal of this file is to help understand the GSW scheme and the implementation of GSWCiphertextin OnionPIR code. Let&rsquo;s start with my understanding of GSW scheme.
From TGSW to RGSW
RGSW is a ring variation of GSW scheme. I do not see any formal paper defining RGSW. However, I do find this particular paper helpful: Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds. This paper defines TLWE and TGSW."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"Understanding GSW","item":"https://ofuro.me/posts/understanding-gsw/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding GSW","name":"Understanding GSW","description":"The goal of this file is to help understand the GSW scheme and the implementation of GSWCiphertextin OnionPIR code. Let\u0026rsquo;s start with my understanding of GSW scheme.\nFrom TGSW to RGSW RGSW is a ring variation of GSW scheme. I do not see any formal paper defining RGSW. However, I do find this particular paper helpful: Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds. This paper defines TLWE and TGSW.\n","keywords":["cryptography"],"articleBody":"The goal of this file is to help understand the GSW scheme and the implementation of GSWCiphertextin OnionPIR code. Let’s start with my understanding of GSW scheme.\nFrom TGSW to RGSW RGSW is a ring variation of GSW scheme. I do not see any formal paper defining RGSW. However, I do find this particular paper helpful: Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds. This paper defines TLWE and TGSW.\nConceptually, TFHE works on torus polynomial: $\\mathbb{T}_N[X] = \\mathbb{R}[X] / (X^N + 1) \\mod 1$, where RGSW works on polynomial ring: $R[X] = \\mathbb{Z}[X] / (X^N + 1)$. $N$ is the degree of the polynomial in both cases. The first definition is briefly given in: OnionPIR: Response Efficient Single-Server PIR.\nLet’s compare these two schemes.\nTGSW Given a base $B \\in \\mathbb{N}$ and a length parameter $\\ell \\in \\mathbb{Z}^+$, we define a gadget vector: $$ g^{(\\ell \\times 1)} = (1/B, \\ldots, 1/B^\\ell)^T $$\nExample: $B = 10, \\ell = 3, g = (1/10^1, 1/10^2, 1/10^3)$.\nThen we use this vector to create TGSW gadget $G$. $$ G=\\mathbf{I}_2 \\otimes g=\\left[\\begin{array}{ll} g \u0026 0 \\\\ 0 \u0026 g \\end{array}\\right] \\in \\mathbb{T}_N[X]^{2 \\ell \\times 2} $$ $$ \\text{TGSW ciphertext: }C = Z + \\mu \\cdot G $$\nWhere $Z$ is $2\\ell$ rows of $\\operatorname{TLWE}(0)$, $\\mu$ is the message of this TGSW ciphertext.\nRGSW Given a base $B \\in \\mathbb{N}$, and the length parameter $\\ell \\in \\mathbb{Z}^+$, RGSW gadget: $$ g^{(\\ell \\times 1)} = \\left(B^{\\log q / \\log B-1}, B^{\\log q / \\log B-2}, \\cdots, B^{\\log q / \\log B- \\ell }\\right) $$\nWhere $q$ is the coefficient modulus for ciphertext. In our implementation, $\\log q / \\log B = l$.\nExample: $B = 10, l = 3, g = (10^2, 10^1, 10^0)$.\nThe connection In application, we deal with TGSW and RGSW in the same way, but only in different range. Since we cannot express $\\mathbb{R}$ in infinite precision – we are in discrete case – TGSW is actually implemented as RGSW. RGSW has integer values from 1 to $q$ and 1 to $t$, where TGSW has discret values from 0 to 1. They share all the algorithms while only differs in the coefficients space.\nGadget Decomposition LWE samples: Gadgets are used for both encrypting the GSW ciphertext, and to decompose LWE ciphertext during the external product.\nLet $\\pmb{v}$ be a TLWE sample. The decomposition of $\\pmb{v}$ outputs an element on a polynomial ring: $\\pmb{u} = \\operatorname{Decomp}(\\pmb{v}) \\in \\mathcal{R}$. Then a correct decomposition means $| \\pmb{u} \\cdot G - \\pmb{v}|_\\infty \u003c \\varepsilon $. We can think of decomposition as a way we extract bits from numbers.\nExample on constant polynomials:\nTGSW: $B = 10, \\ell = 3, g = (1/10, 1/10^2, 1 / 10^3)$, then decomposing $v = 0.468$ becomes: $\\operatorname{Decomp}(v) = (4, 6, 8)$. RGSW: $B = 10, \\ell = 3, g = (10^2, 10^1, 10^0)$, then decomposing $v = 839$ becomes: $\\operatorname{Decomp}(v) = (8, 3, 9)$. External Product and the Usage of Gadgets Check theorem 3.14 in https://eprint.iacr.org/2016/870 to for the details of external product. In the proof, at some point, the decomposed LWE ($\\pmb{u}$) is multiplied by the gadget ($\\pmb{h}$) in the GSW ciphertext. We see a cancelation during this multiplication, makes the homomorphic multiplication possible under the hood.\nInterpretation v.s. Storage We can store RGSW in RLWE form, but shouldn’t interpret it as rows of RLWE. Since RGSW and TGSW are actually the same thing, I will use RGSW here.\nThe first thing to notice is is that we should not interpret each row of RGSW as RLWE (BFV), even though we can (and will) represent them in RLWE form. The $Z$ matrix are rows of RLWE(0). If we treat RLWE as black box, then adding extra values to the coefficients of RLWE will make the ciphertext unpredictable without opening the black box. In fact, we can encrypt a message to a GSW ciphertext, but cannot decrypt the ciphertext and get the message back. In our case, BFV scheme scales the message by a factor ($\\Delta$) during the encryption state. Check Introduction to the BFV encryption scheme for an introduction to BFV scheme.\nIn our case, since we can store each row or RGSW as RLWE, we can use a very specific trick to pack the query, and use the algorithm 3 in Onion-Ring ORAM as a subroutine to unpack the query. By doing this, we reduce the online communication. The following is an important observation. I will use the notation in the link above.\nIn BFV scheme, we have: $$ \\operatorname{BFV}(0) = \\begin{cases} C_1 = [-(a \\cdot SK + e)\\cdot u + e_1]_q = [-a \\cdot SK \\cdot u - e\\cdot u + e_1]_q\\\\ C_2 = [a \\cdot u + e_2]_q \\end{cases} $$ Therefore, if we only look at the first $l$ rows of a RGSW ciphertext, the $i^{\\text{th}}$ row looks like: $$ \\begin{align*} \\operatorname{RGSW}(M)_i \u0026= Z_i + M \\cdot G_i = \\left(\\; C_{i, 1} + M g_i, \\; C_{i, 2} \\;\\right)\\\\ \u0026= \\left(\\; -(a \\cdot SK + e)\\cdot u + e_1 + M g_i, \\; C_{i, 2} \\;\\right)\\\\ \u0026= \\operatorname{BFV^*}(M g_i/\\Delta) \\end{align*} $$ Here, I am using $\\operatorname{BFV^*}( M g_i / \\Delta)$ for a simpler expression. It is not “real” as we won’t get the exact RGSW ciphertext if we encrypt $M g_i / \\Delta$ when $\\Delta \u003e Mg_i$ for each row. The simple reason is: in a discrete case, this division would give 0.\nNext, the bottom $l$ rows. Let $j \\in [l]$ but represent the index of the second $l$ rows. So, $Z_j$ actually means $Z_{j + l}$. $$ \\begin{align*} \\operatorname{RGSW}(M)_j \u0026= Z_j + M \\cdot G = \\left(\\; C_{j, 1}, \\; C_{j, 2} + Mg_j \\;\\right)\\\\ \u0026= \\left(\\; -(a \\cdot SK + e)\\cdot u + e_1, \\; a \\cdot u + e_2 + Mg_i \\;\\right)\\\\ \\end{align*} $$ If we treat the second term as a new $C_{j, 2}’$, decrypting this row using BFV decryption gives us: $$ \\begin{align*} \\text{message}(\\operatorname{RGSW}(M)_j) \u0026= \\left[\\lfloor \\left( C_{j, 1} + (C_{j, 2} + Mg_j) \\cdot \\mathrm{SK} \\right) / \\Delta \\rceil\\right]_t\\\\ \u0026= \\left[\\lfloor \\left(\\left( -a \\cdot u \\cdot \\mathrm{SK} - e \\cdot u + e_1 \\right) + (a \\cdot u \\cdot \\mathrm{SK} + e_2 \\cdot \\mathrm{SK} + Mg_i \\cdot \\mathrm{SK}) \\right) / \\Delta \\rceil\\right]_t\\\\ \u0026\\approx (Mg_j/ \\Delta) \\cdot \\mathrm{SK}\\\\ \u0026\\Updownarrow\\\\ \\operatorname{RGSW}(M)_j \u0026= \\operatorname{BFV^*}((Mg_j/ \\Delta) \\cdot \\mathrm{SK}) \\end{align*} $$ Then the trick is to perform external product betweeen $\\operatorname{RGSW}(\\mathrm{SK})$ and the first $l$ rows, $\\operatorname{BFV^*}(Mg_i/\\Delta)$, to recreate the second $l$ rows of the query RGSW ciphertexts.\n$$ \\operatorname{RGSW}(\\mathrm{SK}) \\boxdot \\operatorname{BFV^*}(Mg_i/\\Delta) = \\operatorname{BFV^*}((Mg_i/\\Delta) \\cdot SK) $$ These are slightly different from what we had in Onion Ring ORAM: Efficient Constant Bandwidth Oblivious RAM from (Leveled) TFHE:\nWrong statement Wrong because encrypting message $\\mu$ won't decomposing it. Instead, it just scales by different factors. It is also almost impossible to decrypt it if using BFV. Different RLWE scheme results in different expression Details in BFV diff from TLWE:\nDecrypting TLWE $C=\\left(c_1, c_2\\right): \\operatorname{Dec}(c)=\\lfloor C_2-SK-\\cdot C_1\\rceil$ Decrypting BFV $C=\\left(C_1, C_2\\right): \\operatorname{Dec}(C)=\\left[\\frac{t\\left[C_1+C_2 \\cdot S K\\right]_q}{q}\\right]_t$ Enc in TLWE: $c=\\left(c_1, c_2\\right)=\\left(c_1, c_1 \\cdot s k+\\mu+e\\right), C_1$ random Enc in BFV: $C=\\left\\{ \\begin{array}{l}{ \\left[-(a \\cdot S K+e) r+e_1+\\lfloor\\frac{q}{t} \\rceil\\, \\cdot \\mu\\right]_q} \\\\ {\\left[a \\cdot r+e_2\\right]_q }\\end{array} \\right\\}$ $\\Delta$ scaling factor ","wordCount":"1195","inLanguage":"en","datePublished":"2024-10-01T21:56:04-06:00","dateModified":"2024-10-01T21:56:04-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/understanding-gsw/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Understanding GSW</h1><div class=post-meta><span title='2024-10-01 21:56:04 -0600 -0600'>October 1, 2024</span></div></header><div class=post-content><p>The goal of this file is to help understand the GSW scheme and the implementation of <code>GSWCiphertext</code>in OnionPIR code. Let&rsquo;s start with my understanding of GSW scheme.</p><h3 id=from-tgsw-to-rgsw>From TGSW to RGSW<a hidden class=anchor aria-hidden=true href=#from-tgsw-to-rgsw>#</a></h3><p>RGSW is a ring variation of <a href=https://eprint.iacr.org/2013/340>GSW scheme</a>. I do not see any formal paper defining RGSW. However, I do find this particular paper helpful: <a href=https:/print.iacr.org/2016/870>Faster Fully Homomorphic Encryption: Bootstrapping in less than 0.1 Seconds</a>. This paper defines TLWE and TGSW.</p><p>Conceptually, TFHE works on torus polynomial: $\mathbb{T}_N[X] = \mathbb{R}[X] / (X^N + 1) \mod 1$, where RGSW works on polynomial ring: $R[X] = \mathbb{Z}[X] / (X^N + 1)$. $N$ is the degree of the polynomial in both cases. The first definition is briefly given in: <a href=https://eprint.iacr.org/2021/1081>OnionPIR: Response Efficient Single-Server PIR</a>.</p><p>Let&rsquo;s compare these two schemes.</p><h4 id=tgsw>TGSW<a hidden class=anchor aria-hidden=true href=#tgsw>#</a></h4><p>Given a base $B \in \mathbb{N}$ and a length parameter $\ell \in \mathbb{Z}^+$, we define a gadget vector:
$$
g^{(\ell \times 1)} = (1/B, \ldots, 1/B^\ell)^T
$$</p><blockquote><p>Example: $B = 10, \ell = 3, g = (1/10^1, 1/10^2, 1/10^3)$.</p></blockquote><p>Then we use this vector to create TGSW gadget $G$.<div>$$
G=\mathbf{I}_2 \otimes g=\left[\begin{array}{ll}
g & 0 \\
0 & g
\end{array}\right] \in \mathbb{T}_N[X]^{2 \ell \times 2}
$$</div></p><p>$$
\text{TGSW ciphertext: }C = Z + \mu \cdot G
$$</p><p>Where $Z$ is $2\ell$ rows of $\operatorname{TLWE}(0)$, $\mu$ is the message of this TGSW ciphertext.</p><h4 id=rgsw>RGSW<a hidden class=anchor aria-hidden=true href=#rgsw>#</a></h4><p>Given a base $B \in \mathbb{N}$, and the length parameter $\ell \in \mathbb{Z}^+$, RGSW gadget:
$$
g^{(\ell \times 1)} = \left(B^{\log q / \log B-1}, B^{\log q / \log B-2}, \cdots, B^{\log q / \log B- \ell }\right)
$$</p><p>Where $q$ is the coefficient modulus for ciphertext. In our implementation, $\log q / \log B = l$.</p><blockquote><p>Example: $B = 10, l = 3, g = (10^2, 10^1, 10^0)$.</p></blockquote><h4 id=the-connection>The connection<a hidden class=anchor aria-hidden=true href=#the-connection>#</a></h4><p>In application, we deal with TGSW and RGSW in the same way, but only in different range. Since we cannot express $\mathbb{R}$ in infinite precision – we are in discrete case – TGSW is actually implemented as RGSW. RGSW has integer values from 1 to $q$ and 1 to $t$, where TGSW has discret values from 0 to 1. They share all the algorithms while only differs in the coefficients space.</p><h4 id=gadget-decomposition-lwe-samples>Gadget Decomposition LWE samples:<a hidden class=anchor aria-hidden=true href=#gadget-decomposition-lwe-samples>#</a></h4><p>Gadgets are used for both encrypting the GSW ciphertext, and to decompose LWE ciphertext during the external product.</p><p>Let $\pmb{v}$ be a TLWE sample. The decomposition of $\pmb{v}$ outputs an element on a polynomial ring: $\pmb{u} = \operatorname{Decomp}(\pmb{v}) \in \mathcal{R}$. Then a correct decomposition means $| \pmb{u} \cdot G - \pmb{v}|_\infty &lt; \varepsilon $. We can think of decomposition as a way we extract bits from numbers.</p><p>Example on constant polynomials:</p><ul><li>TGSW: $B = 10, \ell = 3, g = (1/10, 1/10^2, 1 / 10^3)$, then decomposing $v = 0.468$ becomes: $\operatorname{Decomp}(v) = (4, 6, 8)$.</li><li>RGSW: $B = 10, \ell = 3, g = (10^2, 10^1, 10^0)$, then decomposing $v = 839$ becomes: $\operatorname{Decomp}(v) = (8, 3, 9)$.</li></ul><h4 id=external-product-and-the-usage-of-gadgets>External Product and the Usage of Gadgets<a hidden class=anchor aria-hidden=true href=#external-product-and-the-usage-of-gadgets>#</a></h4><p>Check theorem 3.14 in <a href=https://eprint.iacr.org/2016/870>https://eprint.iacr.org/2016/870</a> to for the details of external product. In the proof, at some point, the decomposed LWE ($\pmb{u}$) is multiplied by the gadget ($\pmb{h}$) in the GSW ciphertext. We see a cancelation during this multiplication, makes the homomorphic multiplication possible under the hood.</p><center><figure><img src="https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/Screenshot 2024-08-17 at 3.15.43 PM.png" style=width:60%><figcaption></figcaption></figure></center><h3 id=interpretation-vs-storage>Interpretation v.s. Storage<a hidden class=anchor aria-hidden=true href=#interpretation-vs-storage>#</a></h3><blockquote><p>We can store RGSW in RLWE form, but shouldn&rsquo;t interpret it as rows of RLWE. Since RGSW and TGSW are actually the same thing, I will use RGSW here.</p></blockquote><p>The first thing to notice is is that we should not interpret each row of RGSW as RLWE (BFV), even though we can (and will) represent them in RLWE form. The $Z$ matrix are rows of RLWE(0). If we treat RLWE as black box, then adding extra values to the coefficients of RLWE will make the ciphertext unpredictable without opening the black box. In fact, we can encrypt a message to a GSW ciphertext, but cannot decrypt the ciphertext and get the message back. In our case, BFV scheme scales the message by a factor ($\Delta$) during the encryption state. Check <a href=https://inferati.com/blog/fhe-schemes-bfv>Introduction to the BFV encryption scheme</a> for an introduction to BFV scheme.</p><p>In our case, since we can store each row or RGSW as RLWE, we can use a very specific trick to pack the query, and use the algorithm 3 in Onion-Ring ORAM as a subroutine to unpack the query. By doing this, we reduce the online communication. The following is an important observation. I will use the notation in the link above.</p><p>In BFV scheme, we have:<div>$$
\operatorname{BFV}(0) =
\begin{cases}
C_1 = [-(a \cdot SK + e)\cdot u + e_1]_q = [-a \cdot SK \cdot u - e\cdot u + e_1]_q\\
C_2 = [a \cdot u + e_2]_q
\end{cases}
$$</div>Therefore, if we only look at the first $l$ rows of a RGSW ciphertext, the $i^{\text{th}}$ row looks like:<div>$$
\begin{align*}
\operatorname{RGSW}(M)_i &= Z_i + M \cdot G_i = 
\left(\;
C_{i, 1} + M g_i, \;
C_{i, 2}
\;\right)\\
&=
\left(\;
-(a \cdot SK + e)\cdot u + e_1 + M g_i, \;
C_{i, 2}
\;\right)\\
&= \operatorname{BFV^*}(M g_i/\Delta)
\end{align*}
$$</div></p><p>Here, I am using $\operatorname{BFV^*}( M g_i / \Delta)$ for a simpler expression. It is not &ldquo;real&rdquo; as we won&rsquo;t get the exact RGSW ciphertext if we encrypt $M g_i / \Delta$ when $\Delta > Mg_i$ for each row. The simple reason is: in a discrete case, this division would give 0.</p><p>Next, the bottom $l$ rows. Let $j \in [l]$ but represent the index of the second $l$ rows. So, $Z_j$ actually means $Z_{j + l}$.<div>$$
\begin{align*}
\operatorname{RGSW}(M)_j
&= Z_j + M \cdot G =
\left(\;
C_{j, 1}, \;
C_{j, 2} + Mg_j
\;\right)\\
&=
\left(\;
-(a \cdot SK + e)\cdot u + e_1, \;
a \cdot u + e_2 + Mg_i
\;\right)\\
\end{align*}
$$</div>If we treat the second term as a new $C_{j, 2}&rsquo;$, decrypting this row using BFV decryption gives us:<div>$$
\begin{align*}
\text{message}(\operatorname{RGSW}(M)_j) &= 
\left[\lfloor \left( 
C_{j, 1} + (C_{j, 2} + Mg_j) \cdot \mathrm{SK}
\right)
/ \Delta \rceil\right]_t\\
&= \left[\lfloor 
\left(\left(
-a \cdot u \cdot \mathrm{SK} - e \cdot u + e_1 \right)
+ (a \cdot u \cdot \mathrm{SK} + e_2 \cdot \mathrm{SK} + Mg_i \cdot \mathrm{SK})
\right)
/ \Delta
\rceil\right]_t\\
&\approx (Mg_j/ \Delta) \cdot \mathrm{SK}\\
&\Updownarrow\\
\operatorname{RGSW}(M)_j &= \operatorname{BFV^*}((Mg_j/ \Delta) \cdot \mathrm{SK})
\end{align*}
$$</div></p><p>Then the trick is to perform external product betweeen $\operatorname{RGSW}(\mathrm{SK})$ and the first $l$ rows, $\operatorname{BFV^*}(Mg_i/\Delta)$, to recreate the second $l$ rows of the query RGSW ciphertexts.</p><div>$$
\operatorname{RGSW}(\mathrm{SK}) \boxdot \operatorname{BFV^*}(Mg_i/\Delta) = \operatorname{BFV^*}((Mg_i/\Delta) \cdot SK)
$$</div><p>These are slightly different from what we had in <a href=https://eprint.iacr.org/2019/736>Onion Ring ORAM: Efficient Constant Bandwidth Oblivious RAM from (Leveled) TFHE</a>:</p><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240820235754193.png style=width:60%><figcaption>Wrong statement</figcaption></figure></center>Wrong because encrypting message $\mu$ won't decomposing it. Instead, it just scales by different factors. It is also almost impossible to decrypt it if using BFV.<center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240821000206810.png style=width:60%><figcaption>Different RLWE scheme results in different expression</figcaption></figure></center><p>Details in BFV diff from TLWE:</p><ul><li>Decrypting TLWE $C=\left(c_1, c_2\right): \operatorname{Dec}(c)=\lfloor C_2-SK-\cdot C_1\rceil$</li><li>Decrypting BFV $C=\left(C_1, C_2\right): \operatorname{Dec}(C)=\left[\frac{t\left[C_1+C_2 \cdot S K\right]_q}{q}\right]_t$</li><li>Enc in TLWE: $c=\left(c_1, c_2\right)=\left(c_1, c_1 \cdot s k+\mu+e\right), C_1$ random</li><li>Enc in BFV:<div>$C=\left\{
\begin{array}{l}{
\left[-(a \cdot S K+e) r+e_1+\lfloor\frac{q}{t} \rceil\, \cdot \mu\right]_q} \\ {\left[a \cdot r+e_2\right]_q
}\end{array}
\right\}$
$\Delta$ scaling factor</div></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://ofuro.me/tags/cryptography/>Cryptography</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>