<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Comparisons on Keyword Support Methods | Yue's Notes</title>
<meta name=keywords content="cryptography"><meta name=description content="The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don&rsquo;t want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.
Metrics

Client storage
Client computation
Online communication
Download size
Offline communication (if any)
Server storage
Server computation
Ability to support multiple clients


Notations:
$m$: the number of key-value pairs."><meta name=author content><link rel=canonical href=https://ofuro.me/posts/keyword-support-methods/><link crossorigin=anonymous href=/assets/css/stylesheet.3f9c3df41d49c1df83c4f93106bd40eae5ce265f122a1a1a99f034136f7c15f5.css integrity="sha256-P5w99B1Jwd+DxPkxBr1A6uXOJl8SKhoamfA0E298FfU=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/keyword-support-methods/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/keyword-support-methods/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="Comparisons on Keyword Support Methods"><meta property="og:description" content="The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don’t want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.
Metrics Client storage Client computation Online communication Download size Offline communication (if any) Server storage Server computation Ability to support multiple clients Notations: $m$: the number of key-value pairs."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-03T18:29:54-06:00"><meta property="article:modified_time" content="2024-07-03T18:29:54-06:00"><meta property="article:tag" content="Cryptography"><meta name=twitter:card content="summary"><meta name=twitter:title content="Comparisons on Keyword Support Methods"><meta name=twitter:description content="The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don&rsquo;t want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.
Metrics

Client storage
Client computation
Online communication
Download size
Offline communication (if any)
Server storage
Server computation
Ability to support multiple clients


Notations:
$m$: the number of key-value pairs."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"Comparisons on Keyword Support Methods","item":"https://ofuro.me/posts/keyword-support-methods/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Comparisons on Keyword Support Methods","name":"Comparisons on Keyword Support Methods","description":"The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don\u0026rsquo;t want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.\nMetrics Client storage Client computation Online communication Download size Offline communication (if any) Server storage Server computation Ability to support multiple clients Notations: $m$: the number of key-value pairs.\n","keywords":["cryptography"],"articleBody":"The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don’t want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.\nMetrics Client storage Client computation Online communication Download size Offline communication (if any) Server storage Server computation Ability to support multiple clients Notations: $m$: the number of key-value pairs.\n$k$: normally this stands for a key in one key-value pair.\nDB: database in the server.\n$N$: the number of entries in the database. This is not $m$.\nChoice of filters Paper: Binary Fuse Filters: Fast and Smaller Than Xor Filters.\nCuckoo hashing Storage space\nrange from 30 to 40% of the theoretial lower bound Query(computation) time\nalmost the same as 4-wise BF Construction time\nClose to XOR filter almost times compared to BF Failure probability\nWe have a detailed analysis in this paper, which basically suggesting that using 3 hash function, instead of 2, has smaller failure probability during construction.\nSummary: let $N = çm$ be the size of the hash table. When $ç \\geq 8$ and when we use 2 hash functions, the hashing failure is $2^{-\\lambda}$, where $$ \\lambda=(1+0.65 s)\\left(3.3 \\log _2(ç)+\\log _2(N)-0.8\\right) $$\nThe catch for 2 hash functions case: if we set $ç = 2$, $\\lambda$ converges to 1 quickly. So, half of the time the construction of the database fails. But we can try a few more times. The failure rate is geometrically decreasing.\nIn 3 hash functions case, if $ç = 3$, we find $\\lambda \\approx 100$.\nBinary fuse filter Storage space 3-wise BF: 13% of the theoretial lower bound 4-wise BF: 8% of the theoretial lower bound Query(computation) time 3-wise BF: Slightly better than 4-wise BF, almost the same as XOR filter 4-wise BF: Slightly worse than 3-wise BF, almost the same as Cuckoo hashing Construction time 3-wise BF: Slightly worse than 4-wise BF 4-wise BF: Slightly better than 3-wise BF Notes:\nBF filter are generally much superior than cuckoo hashing except the query time is very close to 4-wise BF. 3-wise BF takes up more storage to trade for faster query response, compared to 4-wise BF. TODO: Check out Ribbon filter. It is also better than Cuckoo hashing and XOR filter. In this paper it is claimed that binary fuse is better than Ribbon. Is it so? Is it suitable to our scheme (stateful and stateless)?\nLet’s start by investigating how they realize the keyword PIR feature.\nCuckoo Hashing based on Onion The paper Communication–Computation Trade-offs in PIR brought up a very simple method for realizing the keyword support.\nServer initialize $\\kappa$ cuckoo hash table defined by $\\kappa$ hash functions $\\mathrm{H}_1, \\mathrm{H}_2$ and insert all the key-value pairs. This introduces $N = \\kappa m$. $\\kappa$ can be 2 or 3. We have analysis in the cuckoo hashing section.\nAfter the database is configured, the client can use $\\mathrm{H_1, \\ldots, H_\\kappa}$ to calculate the hash for the two positions. This is fast and easy. Then client initiates two PIR queries to get the two indices.\nClient storage $O(1)$ for hash functions + storage for PIR scheme. This is small Client computation. $O(1)$ for computing hashs + computation for PIR scheme. Online communication $\\kappa$ PIR queries. Download size None. Offline communication (if any) None if in stateless PIR scheme. Server storage $N = 2m \\approx $ twice as large as the PIR scheme it uses. Server computation Since $N = 2m$, this is also $\\approx$ twice larger than a normal PIR scheme if we run the black box twice. Ability to support multiple clients Very easy. The server can share the two hash functions $\\mathrm{H_1, H_2}$ to the public for client to download. The database is fixed. Advantage: This scheme works for all index-based PIR schemes. Both stateful and stateless. This completely uses PIR as a black box that stores the cuckoo hashing table as data.\nDisadvantage: 2 or 3 $\\times$ slower than the normal index-based PIR scheme if we assume computation time is proportional to the $N$.\nSparsePIR based on Onion We now focus on the original SparsePIR, not SparsePIR$^g$, not SparsePIR$^c$. So the scheme is based on a partition-based PIR. We have analysis in another file.\nIn here, $d_1 \\in \\set{128, 512, 1024}, \\varepsilon = 0.38, b \\approx 10000$.\nClient storage $O(1)$ 3 hash function key / seed + PIR scheme. Client computation $O(d_1) \u003c 1024$ hash computation, which is very small. But requires preparing query vector for the PIR scheme of $b$ entries. Also not too bad. Online communication Query: $O(d_1)$ + a small PIR query. Response: equal to the size of one PIR response on database of size $m$. This is because they also need to touch on every entries. Download size None. Offline communication (if any) None. Server storage $(1+\\varepsilon)m = (1 + 0.38)m = 1.38m$. $1.1m$ in SparsePIR$^{g}$. Server computation It requires minutes for preprocessing the database. $O(n)$. For the online runtime, SparsePIR requires many FHE dot product $\\pmb{\\mathrm{v_1}} \\cdot \\pmb{\\mathrm{e}}_i, \\forall i \\in [b]$. I would like to learn about the experimental runtime for this part. ?????? DOT PRODUCT? There is no such thing here. Then, the server compute for a PIR query on $b$ many results we get from the previous step. Ability to support multiple clients This is also good enough. Advantage: The response size is the same as a normal index-based PIR scheme (Onion and Spiral here).\nDisadvantage: According to the data provided in their paper, we discover that they do not have any other advantages. The catch of this scheme is that computing the LWE dot product $\\pmb{\\mathrm{v_1}} \\cdot \\pmb{\\mathrm{e}}_i, \\forall i \\in [b]$ is very slow. Say, when comparing the CH-PIR with SparsePIR, the cuckoo hashing method computes 2 PIR queries, but it is still faster than SparsePIR, which only computes a single PIR query on a 1281024$\\times$ smaller “database” (do notice that the entry size is 1281024 larger, don’t know how to compare this as it involves LWE scheme). So, CH with a faster PIR scheme will likely outperform Sparse.\nChalametPIR Using Key-value Filter The server uses 4 hash functions to store $m$ ke5y-value pairs in $N = ç m = 1.08m$ entries. 3 hash -\u003e ç = 1.13. The hash functions are randomly generated by ther server. The server uses these 4 hash functions to generate the database. The performance depends on the Binary Fuse Filter (BFF). In the query state, the client uses the 4 hash functions to compute $\\mathrm{H_1(k), H_2(k), H_3(k), H_4(k)}$ and does one of the the followings: $$ \\begin{cases} \\text{In FrodoPIR, put all 4 indices into one query. Server does LWE multiplication.}\\\\ \\\\ \\text{Naive: perform 4 index-based PIR queries.} \\end{cases} $$ Client storage\n$O(1)$ for 3 or 4 hash funcitons (and client state if in stateful scheme). Client computation\nnegligible query ($O(n)$) and parsing ($O(1)$) time \u003c 1 ms Online communication\nOne PIR query if use dot product in LWE scheme. This is 1 second in Frodo for 1 million 1KB elements. Note that the query size here is $O(N)$. The data in table 3 in ChalametPIR, the query size is about 12 ~ 18$\\times$ larger than SpiralSparsePIR, about 1 4$\\times$ larger than OnionSparsePIR. If we don’t combine all indices in one query, then 4 queries on $N = 1.08m$ database or 3 queries on $N=1.13m$ database. Download size\nAlmost the same as Frodo PIR. Client must download the entire hint. $O(1)$ ~6MB Offline communication (if any)\nThe client downloads the hint from server. Server storage\nRaw database has $N = ç m = 1.08m$ many enties when $k=4$. Nothing more if no server preprocessing. Server computation\nThis involves a LWE matrix vector multiplication. Slightly slower than the Frodo PIR scheme. O(m) 10e6 seconds for 218 × 1 kB DB Ability to support multiple clients\nAccording to FrodoPIR, it is good at scaling. Thoughts: If we simply use PIR as a black box, the best we can do so far is to use key-value filter with 3 hash functions, and possibly add the results together on the server side to reduce response size. This assume that server computation is linear to the size of the database. Otherwise, cuckoo hashing should be better (less request size / fewer rounds). Example: in hint-based stateful PIR, both methods are solid. the difference is that in cuckoo hashing, server must return two partitions instead of one. If using key-value filter, consider false-positive rate and also the larger request size.\nThe way Sparse realize keyword support naturally combined with linear combination, which invovles in dot product. It is unlikely to be optimized anymore.\nFrom this comparison, we want to quickly add cuckoo hashing method for the latest Onion-PIR.\n","wordCount":"1459","inLanguage":"en","datePublished":"2024-07-03T18:29:54-06:00","dateModified":"2024-07-03T18:29:54-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/keyword-support-methods/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/ title=Notes><span>Notes</span></a></li><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Comparisons on Keyword Support Methods</h1><div class=post-meta><span title='2024-07-03 18:29:54 -0600 -0600'>July 3, 2024</span></div></header><div class=post-content><p>The goal is to compare three methods for supporting keyword feature in PIR: Key-value filter in ChalametPIR, Sparse PIR, and the Cuckoo hashing method. In the beginning, we don&rsquo;t want to start by comparing the detailed experimental performances, but we want to list their properties. What they are good / bad at.</p><h3 id=metrics>Metrics<a hidden class=anchor aria-hidden=true href=#metrics>#</a></h3><ul><li>Client storage</li><li>Client computation</li><li>Online communication</li><li>Download size</li><li>Offline communication (if any)</li><li>Server storage</li><li>Server computation</li><li>Ability to support multiple clients</li></ul><hr><h3 id=notations>Notations:<a hidden class=anchor aria-hidden=true href=#notations>#</a></h3><p>$m$: the number of key-value pairs.</p><p>$k$: normally this stands for a key in one key-value pair.</p><p>DB: database in the server.</p><p>$N$: the number of entries in the database. This is not $m$.</p><hr><h2 id=choice-of-filters>Choice of filters<a hidden class=anchor aria-hidden=true href=#choice-of-filters>#</a></h2><p>Paper: <a href=https://arxiv.org/pdf/2201.01174>Binary Fuse Filters: Fast and Smaller Than Xor Filters</a>.</p><h3 id=cuckoo-hashing>Cuckoo hashing<a hidden class=anchor aria-hidden=true href=#cuckoo-hashing>#</a></h3><ul><li><p>Storage space</p><ul><li>range from 30 to 40% of the theoretial lower bound</li></ul></li><li><p>Query(computation) time</p><ul><li>almost the same as 4-wise BF</li></ul></li><li><p>Construction time</p><ul><li>Close to XOR filter almost times compared to BF</li></ul></li><li><p>Failure probability</p><ul><li><p>We have a detailed analysis in <a href=https://eprint.iacr.org/2018/579>this paper</a>, which basically suggesting that using 3 hash function, instead of 2, has smaller failure probability during construction.</p></li><li><p>Summary: let $N = çm$ be the size of the hash table. When $ç \geq 8$ and when we use 2 hash functions, the hashing failure is $2^{-\lambda}$, where
$$
\lambda=(1+0.65 s)\left(3.3 \log _2(ç)+\log _2(N)-0.8\right)
$$</p></li><li><p>The catch for 2 hash functions case: if we set $ç = 2$, $\lambda$ converges to 1 quickly. So, half of the time the construction of the database fails. But we can try a few more times. The failure rate is geometrically decreasing.</p></li><li><p>In 3 hash functions case, if $ç = 3$, we find $\lambda \approx 100$.</p></li></ul></li></ul><h3 id=binary-fuse-filter>Binary fuse filter<a hidden class=anchor aria-hidden=true href=#binary-fuse-filter>#</a></h3><ul><li>Storage space<ul><li>3-wise BF: 13% of the theoretial lower bound</li><li>4-wise BF: 8% of the theoretial lower bound</li></ul></li><li>Query(computation) time<ul><li>3-wise BF: Slightly better than 4-wise BF, almost the same as XOR filter</li><li>4-wise BF: Slightly worse than 3-wise BF, almost the same as Cuckoo hashing</li></ul></li><li>Construction time<ul><li>3-wise BF: Slightly worse than 4-wise BF</li><li>4-wise BF: Slightly better than 3-wise BF</li></ul></li></ul><p>Notes:</p><ul><li>BF filter are generally much superior than cuckoo hashing except the query time is very close to 4-wise BF.</li><li>3-wise BF takes up more storage to trade for faster query response, compared to 4-wise BF.</li></ul><p>TODO: Check out <a href=https://arxiv.org/pdf/2103.02515>Ribbon filter</a>. It is also better than Cuckoo hashing and XOR filter. In this paper it is claimed that binary fuse is better than Ribbon. Is it so? Is it suitable to our scheme (stateful and stateless)?</p><hr><p>Let&rsquo;s start by investigating how they realize the keyword PIR feature.</p><h3 id=cuckoo-hashing-based-on-onion>Cuckoo Hashing based on Onion<a hidden class=anchor aria-hidden=true href=#cuckoo-hashing-based-on-onion>#</a></h3><p>The paper <a href=https://eprint.iacr.org/2019/1483>Communication&ndash;Computation Trade-offs in PIR</a> brought up a very simple method for realizing the keyword support.</p><p>Server initialize $\kappa$ cuckoo hash table defined by $\kappa$ hash functions $\mathrm{H}_1, \mathrm{H}_2$ and insert all the key-value pairs. This introduces $N = \kappa m$. $\kappa$ can be 2 or 3. We have analysis in the cuckoo hashing section.</p><p>After the database is configured, the client can use $\mathrm{H_1, \ldots, H_\kappa}$ to calculate the hash for the two positions. This is fast and easy. Then client initiates two PIR queries to get the two indices.</p><ul><li>Client storage<ul><li>$O(1)$ for hash functions + storage for PIR scheme. This is small</li></ul></li><li>Client computation.<ul><li>$O(1)$ for computing hashs + computation for PIR scheme.</li></ul></li><li>Online communication<ul><li>$\kappa$ PIR queries.</li></ul></li><li>Download size<ul><li>None.</li></ul></li><li>Offline communication (if any)<ul><li>None if in stateless PIR scheme.</li></ul></li><li>Server storage<ul><li>$N = 2m \approx $ twice as large as the PIR scheme it uses.</li></ul></li><li>Server computation<ul><li>Since $N = 2m$, this is also $\approx$ twice larger than a normal PIR scheme if we run the black box twice.</li></ul></li><li>Ability to support multiple clients<ul><li>Very easy. The server can share the two hash functions $\mathrm{H_1, H_2}$ to the public for client to download. The database is fixed.</li></ul></li></ul><h4 id=advantage>Advantage:<a hidden class=anchor aria-hidden=true href=#advantage>#</a></h4><p>This scheme works for all index-based PIR schemes. Both stateful and stateless. This completely uses PIR as a black box that stores the cuckoo hashing table as data.</p><h4 id=disadvantage>Disadvantage:<a hidden class=anchor aria-hidden=true href=#disadvantage>#</a></h4><p>2 or 3 $\times$ slower than the normal index-based PIR scheme if we assume computation time is proportional to the $N$.</p><h3 id=sparsepir-based-on-onion>SparsePIR based on Onion<a hidden class=anchor aria-hidden=true href=#sparsepir-based-on-onion>#</a></h3><p>We now focus on the original SparsePIR, not SparsePIR$^g$, not SparsePIR$^c$. So the scheme is based on a partition-based PIR. We have analysis in another file.</p><p>In here, $d_1 \in \set{128, 512, 1024}, \varepsilon = 0.38, b \approx 10000$.</p><ul><li>Client storage<ul><li>$O(1)$ 3 hash function key / seed + PIR scheme.</li></ul></li><li>Client computation<ul><li>$O(d_1) &lt; 1024$ hash computation, which is very small. But requires preparing query vector for the PIR scheme of $b$ entries. Also not too bad.</li></ul></li><li>Online communication<ul><li>Query: $O(d_1)$ + a small PIR query.</li><li>Response: equal to the size of one PIR response on database of size $m$. This is because they also need to touch on every entries.</li></ul></li><li>Download size<ul><li>None.</li></ul></li><li>Offline communication (if any)<ul><li>None.</li></ul></li><li>Server storage<ul><li>$(1+\varepsilon)m = (1 + 0.38)m = 1.38m$.</li><li>$1.1m$ in SparsePIR$^{g}$.</li></ul></li><li><strong>Server computation</strong><ul><li>It requires minutes for preprocessing the database. $O(n)$.</li><li>For the online runtime, SparsePIR requires many FHE dot product $\pmb{\mathrm{v_1}} \cdot \pmb{\mathrm{e}}_i, \forall i \in [b]$. I would like to learn about the experimental runtime for this part. ?????? DOT PRODUCT? There is no such thing here.</li><li>Then, the server compute for a PIR query on $b$ many results we get from the previous step.</li></ul></li><li>Ability to support multiple clients<ul><li>This is also good enough.</li></ul></li></ul><h4 id=advantage-1>Advantage:<a hidden class=anchor aria-hidden=true href=#advantage-1>#</a></h4><p>The response size is the same as a normal index-based PIR scheme (Onion and Spiral here).</p><h4 id=disadvantage-1>Disadvantage:<a hidden class=anchor aria-hidden=true href=#disadvantage-1>#</a></h4><p>According to the data provided in their paper, we discover that they do not have any other advantages. The catch of this scheme is that computing the LWE dot product $\pmb{\mathrm{v_1}} \cdot \pmb{\mathrm{e}}_i, \forall i \in [b]$ is very slow. Say, when comparing the CH-PIR with SparsePIR, the cuckoo hashing method computes 2 PIR queries, but it is still faster than SparsePIR, which only computes a single PIR query on a 128<del>1024$\times$ smaller &ldquo;database&rdquo; (do notice that the entry size is 128</del>1024 larger, don&rsquo;t know how to compare this as it involves LWE scheme). So, CH with a faster PIR scheme will likely outperform Sparse.</p><center><figure><img src=https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240627121734575.png style=width:80%><figcaption></figcaption></figure></center><h3 id=chalametpir-using-key-value-filter>ChalametPIR Using Key-value Filter<a hidden class=anchor aria-hidden=true href=#chalametpir-using-key-value-filter>#</a></h3><p>The server uses 4 hash functions to store $m$ ke5y-value pairs in $N = ç m = 1.08m$ entries. 3 hash -> ç = 1.13. The hash functions are randomly generated by ther server. The server uses these 4 hash functions to generate the database. The performance depends on the Binary Fuse Filter (BFF). In the query state, the client uses the 4 hash functions to compute $\mathrm{H_1(k), H_2(k), H_3(k), H_4(k)}$ and does one of the the followings:<div>$$
\begin{cases}
\text{In FrodoPIR, put all 4 indices into one query. Server does LWE multiplication.}\\
\\
\text{Naive: perform 4 index-based PIR queries.}
\end{cases}
$$</div></p><ul><li><p>Client storage</p><ul><li>$O(1)$ for 3 or 4 hash funcitons (and client state if in stateful scheme).</li></ul></li><li><p>Client computation</p><ul><li>negligible query ($O(n)$) and parsing ($O(1)$) time &lt; 1 ms</li></ul></li><li><p>Online communication</p><ul><li>One PIR query if use dot product in LWE scheme. This is <del>1 second in <a href=https://eprint.iacr.org/2022/981>Frodo</a> for 1 million 1KB elements. Note that the query size here is $O(N)$. The data in table 3 in ChalametPIR, the query size is about 12 ~ 18$\times$ larger than SpiralSparsePIR, about 1</del> 4$\times$ larger than OnionSparsePIR.</li><li>If we don&rsquo;t combine all indices in one query, then 4 queries on $N = 1.08m$ database or 3 queries on $N=1.13m$ database.</li></ul></li><li><p>Download size</p><ul><li>Almost the same as Frodo PIR. Client must download the entire hint.</li><li>$O(1)$ ~6MB</li></ul></li><li><p>Offline communication (if any)</p><ul><li>The client downloads the hint from server.</li></ul></li><li><p>Server storage</p><ul><li>Raw database has $N = ç m = 1.08m$ many enties when $k=4$.</li><li>Nothing more if no server preprocessing.</li></ul></li><li><p>Server computation</p><ul><li>This involves a LWE matrix vector multiplication.</li><li>Slightly slower than the Frodo PIR scheme.</li><li>O(m) 10e6 seconds for 218 × 1 kB DB</li></ul></li><li><p>Ability to support multiple clients</p><ul><li>According to FrodoPIR, it is good at scaling.</li></ul></li></ul><hr><h3 id=thoughts>Thoughts:<a hidden class=anchor aria-hidden=true href=#thoughts>#</a></h3><p>If we simply use PIR as a black box, the best we can do so far is to use key-value filter with 3 hash functions, and possibly add the results together on the server side to reduce response size. This assume that server computation is linear to the size of the database. Otherwise, cuckoo hashing should be better (less request size / fewer rounds). Example: in hint-based stateful PIR, both methods are solid. the difference is that in cuckoo hashing, server must return two partitions instead of one. If using key-value filter, consider false-positive rate and also the larger request size.</p><p>The way Sparse realize keyword support naturally combined with linear combination, which invovles in dot product. It is unlikely to be optimized anymore.</p><p>From this comparison, we want to quickly add cuckoo hashing method for the latest Onion-PIR.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ofuro.me/tags/cryptography/>Cryptography</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>