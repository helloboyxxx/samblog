<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>413_basic counting | Yue's Notes</title>
<meta name=keywords content="Combinatorics"><meta name=description content="The four basic counting principle
Suppose that a set $S$ is partitioned into pairwise disjoint parts $S_1, S_2, &mldr;, S_n$.
Addition principle:
$$
|S| = |S_1| + |S_2| + &mldr; + |S_m|
$$
Ex:
Path counting: In a $3 \times 3$ grid, if you can move 1 step upward or 1 step to the right. How many ways do we have to move from bottom-left to top-right corner?
The idea is to break this problem into smaller problems. Addition principle guarrantees that we can add the numbers together."><meta name=author content><link rel=canonical href=https://ofuro.me/posts/413_basic_counting/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ofuro.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ofuro.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ofuro.me/favicon-32x32.png><link rel=apple-touch-icon href=https://ofuro.me/apple-touch-icon.png><link rel=mask-icon href=https://ofuro.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ofuro.me/posts/413_basic_counting/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.onload=function(){MathJax.typesetPromise().then(()=>{console.log("MathJax rendering complete.")})}</script><script src=//yihui.org/js/math-code.js defer></script><meta property="og:url" content="https://ofuro.me/posts/413_basic_counting/"><meta property="og:site_name" content="Yue's Notes"><meta property="og:title" content="413_basic counting"><meta property="og:description" content="The four basic counting principle Suppose that a set $S$ is partitioned into pairwise disjoint parts $S_1, S_2, …, S_n$.
Addition principle: $$ |S| = |S_1| + |S_2| + … + |S_m| $$
Ex:
Path counting: In a $3 \times 3$ grid, if you can move 1 step upward or 1 step to the right. How many ways do we have to move from bottom-left to top-right corner?
The idea is to break this problem into smaller problems. Addition principle guarrantees that we can add the numbers together."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-28T14:35:27-05:00"><meta property="article:modified_time" content="2023-08-28T14:35:27-05:00"><meta property="article:tag" content="Combinatorics"><meta name=twitter:card content="summary"><meta name=twitter:title content="413_basic counting"><meta name=twitter:description content="The four basic counting principle
Suppose that a set $S$ is partitioned into pairwise disjoint parts $S_1, S_2, &mldr;, S_n$.
Addition principle:
$$
|S| = |S_1| + |S_2| + &mldr; + |S_m|
$$
Ex:
Path counting: In a $3 \times 3$ grid, if you can move 1 step upward or 1 step to the right. How many ways do we have to move from bottom-left to top-right corner?
The idea is to break this problem into smaller problems. Addition principle guarrantees that we can add the numbers together."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ofuro.me/posts/"},{"@type":"ListItem","position":2,"name":"413_basic counting","item":"https://ofuro.me/posts/413_basic_counting/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"413_basic counting","name":"413_basic counting","description":"The four basic counting principle Suppose that a set $S$ is partitioned into pairwise disjoint parts $S_1, S_2, \u0026hellip;, S_n$.\nAddition principle: $$ |S| = |S_1| + |S_2| + \u0026hellip; + |S_m| $$\nEx:\nPath counting: In a $3 \\times 3$ grid, if you can move 1 step upward or 1 step to the right. How many ways do we have to move from bottom-left to top-right corner?\nThe idea is to break this problem into smaller problems. Addition principle guarrantees that we can add the numbers together.\n","keywords":["Combinatorics"],"articleBody":"The four basic counting principle Suppose that a set $S$ is partitioned into pairwise disjoint parts $S_1, S_2, …, S_n$.\nAddition principle: $$ |S| = |S_1| + |S_2| + … + |S_m| $$\nEx:\nPath counting: In a $3 \\times 3$ grid, if you can move 1 step upward or 1 step to the right. How many ways do we have to move from bottom-left to top-right corner?\nThe idea is to break this problem into smaller problems. Addition principle guarrantees that we can add the numbers together.\nThink of the final step we need to take. It must be either an up or a right. This makes the problem to become a similar but smaller problem that has $2 \\times 3$ size. Mark it $n_{2\\times 3}$\nUsing the same idea, we have: \\begin{align*} n_{3 \\times 3} = 2 * n_{2 \\times 3} = 2 * (n_{2 \\times 2} + n_{3 \\times 1})\\\\ \\end{align*}\nMultiplication principle Let $S$ be a set of ordered pairs $(a, b)$ of objects, where the first object $a$ comes from a set of size $p$, and for each choice of object $a$ there are q choices for object $b$. Then the size of $S$ is $$ |S| = p \\cdot q $$\nGeneralized multiplicative principle\nLet $S$ be a finite set of $p$-tuples $a = (a_1, …, a_p)$ and let $t_1, …, t_p$ be some positive numbers.\nSuppose that for every $a = (a_1, …, a_p) \\in S$, and every $i \\in \\set{1, …, p}$, we have $$ |\\set{b \\in S:b_j = a_j, \\forall j \\neq i}| = t_i $$ Then, $$ |S| = t_1 \\cdot t_2 \\cdot … t_p $$ (4) counts the number of choices if we fix all other dimension except $i$.\nEx:\nDetermine the number of positive integers that are factors of the number $2^{10}\\cdot 7 \\cdot 13^3$.\nThis number can be written as: $2^{a}\\cdot 7^b \\cdot 13^c$. Then just consider the number of choices for $a, b, c$:\n$a \\in \\set{0, 1, … 10}$ $b \\in \\set{0, 1}$ $c \\in \\set{0, 1, 2, 3}$\nIn total, $11 \\cdot 2 \\cdot 4 = 88$\nObservation In the multiplication principle the $q$ choices for object $b$ may vary the choice of $a$. The only requirement is that there be the same number $q$ of choices, not necessarily the same choices.\n(When we choose one coordinate, the choices for other coordinates changes)\nEx:\nHow many two-digit numbers have distinct and nonzero digits?\n9 * 8 = 72. The first digit has 9 choices, the second digit has 8 (since 0 and the 1st choice are not allowed)\nSubtraction Principle Let $A$ be a set and let $U$ be a larger set containing $A$. Let $$ \\bar{A} = U \\setminus A = \\set{x \\in U : x \\notin A} $$\nEx:\nComputer passwords are consist of a string of six symbols taken from digit 0 to 9 and letters a to z.\nHow many computer passwords have a repeat symbol?\nans: The number of total passwords - passwords that don’t repeat.\n= $36^6 - 36 * 35 * 34 * 33 * 32 * 31$\nDivision principle Let $S$ be a finite set htat is partitioned into k parts in such a way that each part contains the same number of objects. Then the number of parts in the partition is given by the rule. $$ k = \\frac{|S|}{|S_i|} $$ A multiset is a modification of the concept of a set that, unlike a set, allows for multiple instances for each of its elements.\nEx: $\\set{a, a, b}$ the element a has multiplicity 2, and b has multiplicity 1.\nDivision principle for multisets\nLet $S$ be a finite multiset in which each element has the same multiplicity $m$, Let $A$ be the underlying set of $S$, formed from its distinct elements. The the size is given by: $$ |A| = \\frac{|S|}{m} $$\nReference: https://lmattos.web.illinois.edu/math-413-lecture-log/, MATH 413, Leticia Dias Mattos\n","wordCount":"655","inLanguage":"en","datePublished":"2023-08-28T14:35:27-05:00","dateModified":"2023-08-28T14:35:27-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ofuro.me/posts/413_basic_counting/"},"publisher":{"@type":"Organization","name":"Yue's Notes","logo":{"@type":"ImageObject","url":"https://ofuro.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ofuro.me/ accesskey=h title="Yue's Notes (Alt + H)">Yue's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ofuro.me/about title="About Me"><span>About Me</span></a></li><li><a href=https://ofuro.me/archives title=Archive><span>Archive</span></a></li><li><a href=https://ofuro.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ofuro.me/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">413_basic counting</h1><div class=post-meta><span title='2023-08-28 14:35:27 -0500 -0500'>August 28, 2023</span></div></header><div class=post-content><h1 id=the-four-basic-counting-principle>The four basic counting principle<a hidden class=anchor aria-hidden=true href=#the-four-basic-counting-principle>#</a></h1><p>Suppose that a set $S$ is partitioned into pairwise disjoint parts $S_1, S_2, &mldr;, S_n$.</p><h3 id=addition-principle><strong>Addition principle:</strong><a hidden class=anchor aria-hidden=true href=#addition-principle>#</a></h3><p>$$
|S| = |S_1| + |S_2| + &mldr; + |S_m|
$$</p><p>Ex:</p><p>Path counting: In a $3 \times 3$ grid, if you can move 1 step upward or 1 step to the right. How many ways do we have to move from bottom-left to top-right corner?</p><p>The idea is to break this problem into smaller problems. Addition principle guarrantees that we can add the numbers together.</p><p>Think of the final step we need to take. It must be either an up or a right. This makes the problem to become a similar but smaller problem that has $2 \times 3$ size. Mark it $n_{2\times 3}$</p><p>Using the same idea, we have:
<code>\begin{align*} n_{3 \times 3} = 2 * n_{2 \times 3} = 2 * (n_{2 \times 2} + n_{3 \times 1})\\ \end{align*}</code></p><h3 id=multiplication-principle><strong>Multiplication principle</strong><a hidden class=anchor aria-hidden=true href=#multiplication-principle>#</a></h3><p>Let $S$ be a set of ordered pairs $(a, b)$ of objects, where the first object $a$ comes from a set of size $p$, and for each choice of object $a$ there are q choices for object $b$. Then the size of $S$ is
$$
|S| = p \cdot q
$$</p><p><strong>Generalized multiplicative principle</strong></p><p>Let $S$ be a finite set of $p$-tuples $a = (a_1, &mldr;, a_p)$ and let $t_1, &mldr;, t_p$ be some positive numbers.</p><p>Suppose that for every $a = (a_1, &mldr;, a_p) \in S$, and every $i \in \set{1, &mldr;, p}$, we have
$$
|\set{b \in S:b_j = a_j, \forall j \neq i}| = t_i
$$
Then,
$$
|S| = t_1 \cdot t_2 \cdot &mldr; t_p
$$
(4) counts the number of choices if we fix all other dimension except $i$.</p><p>Ex:</p><p><strong>Determine the number of positive integers that are factors of the number $2^{10}\cdot 7 \cdot 13^3$.</strong></p><p>This number can be written as:
$2^{a}\cdot 7^b \cdot 13^c$.
Then just consider the number of choices for $a, b, c$:</p><p>$a \in \set{0, 1, &mldr; 10}$
$b \in \set{0, 1}$
$c \in \set{0, 1, 2, 3}$</p><p>In total, $11 \cdot 2 \cdot 4 = 88$</p><h3 id=observation><strong>Observation</strong><a hidden class=anchor aria-hidden=true href=#observation>#</a></h3><p>In the multiplication principle the $q$ choices for object $b$ may vary the choice of $a$. The only requirement is that there be the same number $q$ of choices, not necessarily the same choices.</p><p>(When we choose one coordinate, the choices for other coordinates changes)</p><p>Ex:</p><p>How many two-digit numbers have distinct and nonzero digits?</p><p>9 * 8 = 72. The first digit has 9 choices, the second digit has 8 (since 0 and the 1st choice are not allowed)</p><h3 id=subtraction-principle><strong>Subtraction Principle</strong><a hidden class=anchor aria-hidden=true href=#subtraction-principle>#</a></h3><p>Let $A$ be a set and let $U$ be a larger set containing $A$. Let
$$
\bar{A} = U \setminus A = \set{x \in U : x \notin A}
$$</p><p>Ex:</p><p>Computer passwords are consist of a string of six symbols taken from digit 0 to 9 and letters a to z.</p><p>How many computer passwords have a repeat symbol?</p><p>ans: The number of total passwords - passwords that don&rsquo;t repeat.</p><p>= $36^6 - 36 * 35 * 34 * 33 * 32 * 31$</p><h3 id=division-principle><strong>Division principle</strong><a hidden class=anchor aria-hidden=true href=#division-principle>#</a></h3><p>Let $S$ be a finite set htat is partitioned into k parts in such a way that each part contains the <strong>same</strong> number of objects. Then the number of parts in the partition is given by the rule.
$$
k = \frac{|S|}{|S_i|}
$$
A multiset is a modification of the concept of a set that, unlike a set, allows for multiple instances for each of its elements.</p><p>Ex: $\set{a, a, b}$ the element a has multiplicity 2, and b has multiplicity 1.</p><p><strong>Division principle for multisets</strong></p><p>Let $S$ be a finite multiset in which each element has the same multiplicity $m$, Let $A$ be the underlying set of $S$, formed from its distinct elements. The the size is given by:
$$
|A| = \frac{|S|}{m}
$$</p><h3 id=reference>Reference:<a hidden class=anchor aria-hidden=true href=#reference>#</a></h3><p><a href=https://lmattos.web.illinois.edu/math-413-lecture-log/>https://lmattos.web.illinois.edu/math-413-lecture-log/</a>, MATH 413, Leticia Dias Mattos</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ofuro.me/tags/combinatorics/>Combinatorics</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ofuro.me/>Yue's Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>